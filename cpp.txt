C++

1.- COMPILAR CODIGO C++
2.- CORRER PROGRAMA
3.- CODIGO BASICO
4.- SALIDA DE CONSOLA
5.- DECLARAR VARIABLES
6.- ASIGNAR VALOR A LAS VARIABLES DESDE CONSOLA
7.- MOSTRAR VALOR DE VARIABLE EN SALIDADE CONSOLA
8.- IF
9.- OPERADORES RELACIONALES
10.- OPERADORES MATEMATICOS
11.- OPERADORES LOGICOS
12.- WHILE
13.- DO WHILE
14.- FOR
15.- CADENA DE CARACTERES MEDIANTE VECTORES
16.- DECLARACION DE UNA CLASE Y DEFINICION DE OBJETOS
17.- SINTAXIS DE UN METODO
18.- ESTRUCTURA DE DATOS TIPO VECTOR EN C++
19.- ESTRUCTURA DE DATOS TIPO MATRIZ
20.- CONSTRUCTOR DE LA CLASE
21.- DESTRUCTOR DE LA CLASE
22.- PARTE PRIVATE Y PUBLIC DE UNA CLASE EN C++
23.- SOBRECARGA DE METODOS
24.- COLABORACION DE CLASES EN C++


1.- COMPILAR CODIGO C++
g++ file.cpp -o file

2.- CORRER PROGRAMA
./file

3.- CODIGO BASICO
#include<iostream>

using namespace std;

int main(){

	return 0;
}

4.- SALIDA DE CONSOLA
cout <<"Hola mundo.";

5.- DECLARAR VARIABLES
int intVar;
int intVar = 0;

float floatVar;

6.- ASIGNAR VALOR A LAS VARIABLES DESDE CONSOLA
cin >>intVar;
cin >>floarVar;

7.- MOSTRAR VALOR DE VARIABLE EN SALIDADE CONSOLA
int intVar=19;

cout <<intVar;

8.- IF
if (condicion)
{
	accion();
}

float sueldo=0;

if (sueldo>3000)
{
	cout<<"Esta persona debe abonar impuestos";
}

if(sueldo>3000)
{
	accion1();
}
else
{
	accion2();
}

if(suldo>3000)
{
	accion1();
}
else
{
	if(sueldo==1000)
	{
		accion2()
	}
	else
	{
		accion3()
	}
}

if(suldo>3000)
{
	accion1();
}
else if (sueldo==2000)
{
	accion2();
}
else
{
	accion3();
}

if(sueldo<1000 || sueldo>3000)
{
	accion1();
}

9.- OPERADORES RELACIONALES
== Igualdad
!= diferente
> Mayor que
>= Mayor o igual que
< Menor que
<= Menor o igual que

10.- OPERADORES MATEMATICOS
+ Suma
- Resta
* Multiplicacion
/ Division
% Resto de la division

11.- OPERADORES LOGICOS
&& and
|| or

12.- WHILE
int x;
x=1;

while (x<=100)
{
	cout<<x;
	cout<<" - ";
	x=x+1;
}


int n, x;
n=10;
x=1;

while (x<=n)
{
	cout<<x;
	cout<<" - ";
	x=x+1;
}

13.- DO WHILE
int valor;

do
{
	accion();
}
while(valor!=0);

14.- FOR
int f;
for(f=1; f<=100; f++)
{
	cout<<f;
	cout<<"=";
}

for(int x=0; x<=10; x++)
{
	accion();
}

15.- CADENA DE CARACTERES MEDIANTE VECTORES
char <nombre> [<Cantidad de caracteres>];

char cadena[8];

La variable cadena puede almacenar hasta 7 caracteres (lo definimos de 8 ya que requiere un caracter para indicar el fin).
El terminador de cadena es \0.

char cadena[8]="hola";

char mes1[20]="enero";

cout<<mes1;

Para ingresar cadenas de caracteres por teclado debemos emplear el metodo getline del objeto cin (le pasamos como parametro la cadena a ingresar y el tamano de la cadena)

cin.getline(cadena, 40);

char nombre[40]
cout<<"Ingrese su nombre: ";

cin.getline(nombre, 40);

cout<<"El nombre ingresado es: ";
cout<<nombre;

Comparar cadenas
int strcmp(cadena1, cadena2)

Retorna 0 si las dos cadenas son exactamente iguales, mayor a cero si cadena1 es mayor alfabeticamente que cadena2 y meno a cero en caso contrario.

if (strcmp(cadena1, cadena2)==0)
{
	cout<<"Son iguales";
}

16.- DECLARACION DE UNA CLASE Y DEFINICION DE OBJETOS
#include <iostream>

using namespace std;

class Persona{
	private:
		char nombre[40];
		int edad;
	public:
		void inicializar();
		void implimir();
		void esMayorEdad();
};

void Persona::inicializar()
{
	cout<<"Ingrese nombre: ";
	cin.getline(nombre, 40);
	cout<<"Ingrese edad: "'
	cin>>edad;
}

void Persona::imprimir()
{
	cout<<"Nombre: ";
	cout<<nombre;
	cout<<"\n";
	cout<<"Edad: ";
	cout<<edad;
	cout<<"\n";
}

void Persona::esMayorEdad()
{
	if(edad>=18)
	{
		cout<<"Es mayor de edad.";
	}
	else
	{
		cout<<"No es mayor de edad.";
	}

	cin.get();
	cin.get();
}

int main()
{
	Persona persona1;
	persona1.inicializar();
	persona1.imprimir();
	persona1.esMayorEdad();

	return 0;
}

17.- SINTAXIS DE UN METODO
Sintaxis:

void [nombre de la clase]::[nombre del metodo]()
{
	[algoritmo]
}

Metodo con parametros

void [nombre de la clase]::[nombre del metodo]([parametros])
{
	[algoritmo]
}

Los parametros los podemos imaginar como variables locales al metodo, pero su valor se inicializa con datos que llegan cuando lo llamamos.

#include<iostrem>

using namespace std;

clss TablaMultiplicar{
	private:
		void calcular(int v);
	public:
		void cargarValor();
};

void TablaMultiplicar::calcular(int v)
{
	for(int f=v; f<=v*10; f=f+v)
	{
		cout <<f;
		cout<<"-";
	}

	cout<<"\n";
}

void TablaMultiplicar::cargarValor()
{
	int valor;

	do{
		cout <<"Ingrese un valor (-1 para finalizar): ";
		cin >>valor;

		if(valor!=-1)
		{
			calcular(valor);
		}
	} while (valor!=-1);
}

int main()
{
	TablaMultiplicar tabla1;
	tabla1.cargarValor();
	return 0;
}

Un metodo puede no tener parametros como hemos visto en problemas anteriores o puede tener uno o mas parametros (en caso de tener mas de un parametro los mismos se separan por coma).

Metrods que retornan un dato

[tipo de dato] [nombre de la clase]::[nombre del metodo]([parametros])
{	
	[algoritmo]
	return [tipo de dato]
}

#include<iostream>

using namespace std;

class MayorMenor{
	public:
		int calcularMenor(int v1, int v2, int v3);
};

int MayorMenor::calcularMenor(int v1, int v2, int v3)
{
	int m;

	if(v1<v2 && v1<v3)
	{
		m=v1;
	}
	else{
		if(v2<v2)
		{
			m=v2;
		}
		else{
			m=v3;
		}
	}

	return m;
}

int main()
{
	int valor;

	MayorMenor mayormenor1;
	valor = mayormenor1.calcularMenor(1, 2, 3);

	return 0;
}

18.- ESTRUCTURA DE DATOS TIPO VECTOR EN C++
Un vector es una estructura de datos que permite alamcenar un conjunto de datos del mismo tipo. Con un unico nombre se define un vector y por medio de un subindice hacemos regerencia a cada elemento del mismo (componente).

#include<iosgtream>

using namespace std;

class PruebaVector1{
	private:
		int sueldos[5];
	public:
		void cargar();
		void imprimir();
};

void PruebaVector1::cargar()
{
	for(int f=0; f<5; f++)
	{
		cout <<"Ingrese valor del sueldo: ";
		cin >>sueldos[f];
	}
}

void PruebaVector1::imprimir()
{
	cout <<"Listado de sueldos.";
	cout <<"\n";

	for(int f = 0; f<5; f++)
	{
		cout <<sueldos[f];
		cout <<"\n";
	}

	cin.get();
	cin.get();
}

int main()
{
	PruebaVector1 pv1;
	pv1.cargar();
	pv1.imprimir();

	return 0;
}

int sueldos[5]
Lo definimos como atributo de la clase ya que lo utilizatemos en los dos metodos y ademas lo ubicamos en la zona private para no poder accederlo fuera de la clase.

19.- ESTRUCTURA DE DATOS TIPO MATRIZ
Una matriz es una estructura de datos que permite almacenar un conjunto de datos del mismo tipo. Con una unico nombre se define la matriz y por medio de dos subindices hacemos referencia a cada elemento de la misma (componente).

		Columnas
Filas	50	5	27	400	7
		0	67	90	6	97
		30	14	23	251	490

Hemos graficado una matriz de 3 filas y 5 columnas. Para hacer referencia a cada elemento debemos indicar primero la fila y luego la columna, por ejemplo en la componente 1, 4  se alamcena el valor 97.

int mat [3][5];

20.- CONSTRUCTOR DE LA CLASE
En c++ podemos definir un metodo que se ejecute inicialmente y en forma automatica. Este metodo se lo llama constuctor.

Elconstructor tiene las siguientes caracteristicas:
- Tiene el mismo nombre de la clase.
- Es el primer metodo que se ejecuta.
- Se ejecuta en forma automatica.
- No puede retornar datos.
- Se ejecuta una unica vez.
- Un constuctor tiene por objetivo inicializar atributos.

#include<iostream>

using namespace std;

class operarios{
	private:
		float sueldos[5];
	public:
		Operarios();
		void imprimir();
};

Operarios::Operarios(){
	cout<<"Carga de sueldos. " <<"\n";

	for(int f=0; f<5; f++){
		cout<<"Ingrese el sueldo: ";
		cin>>sueldos[f];
	}
}

void Operarios::imprimir(){
	for(int f=0; f<5; f++){
		cout<<sueldos[f] <<"\n";
	}

	cin.get();
	cin.get();
}

int main(){
	Operarios op;
	op.imprimir();

	return 0;
}

21.- DESTRUCTOR DE LA CLASE
En C++ podemos definir un metodo que se ejecute cuando se elimine el objeto y en forma automatica. Este metodo se lo llama destructor.

El destructor tiene las siguientes caracteristicas:
- Tiene el mismo nombre de la clase mas el caracter ~ al principio.
- Es el ultimo metodo que se ejecuta.
- Se ejecuta en forma automatica.
- No puede retornar datos.
- Se ejcuta una unica vez.
- No es obligatorio.

#include<iostream>

using namespace std;

class Tabla{
	private:
		int valor;
	public:
		Tabla();
		void imprimir();
		~Tabla();
};

Tabla::Tabla(){
	cout<<"Ingrese un valor: ";
	cin>>valor;
}

void Tabla::imprimir(){
	for(int f=vlaor; f<=valor*10; f=f+valor){
		cout<< f << "-";
	}
	
	cout<<"\n";
}

Tabla::~Tabla(){
	cout<<"Gracias por utilizar este programa.";
	cin.get();
	cin.get();
}

int main(){
	Tabla tabla1;
	tabla1.imprimir();

	return 0;
}

Luego de llamar a metodo imprimir llega la llave del final de la main pero previo a esto se llama el destructor de la clase Tabla.

22.- PARTE PRIVATE Y PUBLIC DE UNA CLASE EN C++
Uno de los principios fundamentales de la programacion orientada a objetos es el encapsulamiento, esto se logra agrupando una serie de metodos (funciones) y atributos (varibles) dentro de una clase.

Hemos visto que una clase tiene dos secciones: una publica y otra privada. Por principios de la programacion orientada a objetos los atributos (variables) deben definirse en la parte privada y los metodos dependiendo si queremos que se los pueda llamar desde la main los definiremos de tipo publico y si queremos que queden ocultos y solo puedan ser llamados dentro de la clase los definimos en la parte privada.

#include<iostream>
#include<cstdlib>
#include<ctime>

using namespace std;

class Dado{
	private:
		int valor;
		void separador();
	public:
		void tirar();
		void imprimir();
};

void Dado::separador(){
	cout<<"********************************";
	cout<<"\n";
}

void Dado::tirar(){
	srand(time(NULL));
	valor=rand()%6+1;
}

void Dado::imprimir(){
	seaparador();
	cout<<valor;
	cout<<"\n";
	separador();
}

int main(){
	Dado d;
	d.tirar();
	d.imprimir();

	return 0;
}

El atributo valor y el metodo separador() como estan antecedidas por la palabra clave private: significa que desde la main no se podran acceder, es decir que si escribimos en la main lo siguiente se genera un error sintactico.

La ventaja dee definir losatributos en al zona privada de la clase es que en el caso de haber un error logico en nuestro programa el mismo queda encapsulado en una clase y es mas facil identificarlo.

Dentro de la clase para llamar a otro metodo de la misma clase lo hacemos indicando solo el nombre del otro metodo (dentro del metodo imprimir llamamos al metodo separador por su nombre).

Importante
Una forma muy comun de escribir la declaracion de una clase es obviar la palabra clave private:

class Dado {
	int valor;
	void separador();
	public:
		void tirar();
		void imprimir();
};

El lenguaje C++ inclusive nos permite especificar varias secciones privadas y publicas:

class Dado{
	public:
		void tirar();
	private:
		int valor;
		void separar();
	public:
		void imprimir();
};

23.- SOBRECARGA DE METODOS
Otra caracteristica de C++ con respecto a los metodos es que podemos definir varios con el mismo nombre.

Cuando definimos dos o mas metodos con el mismo nombre decimos que los estamos sobrecargando.

La resticcion para la sobrecarga de metodos es qeu lso mismos deben diferir en cantidad o tipo de parametros. Es decir podemos definir dos metodos con el mismo nombre pero uno tenga por ejemplo 3 parametros y otro tenga 2 parametros:

void mayor(int x1, int x2, int x3)
void mayor(int x1, int x2)

O tengan la misma cantidad de parametros pero sean de distinto tipo:

void mayor(int x1, int x2)
void mayor(char nombre1[40], char nombre2[40])

Sobrecarga del constructor

Como sabemos el constructor es un metodo de la clase y como tal podemos sobrecargarlo, es decir definir mas de un constructor.

Cuando definimos un objeto de la clase es cuando indicamos a que constructo llamaremos segun nuestras necesidades.

24.- COLABORACION DE CLASES EN C++
Normalmente un problema resulto con la metodologia de programacion orientada a objetos no interviene una sola clase, sino que hay muchas clases que interactuan y se comunican.

Plantearemos un problema separando las actividades en dos clases.

archivo1.cpp
#include<iostream>

using namespace std;

class Cliente {
	char nombre[40];
	float monto;

	public:
		Cliente(const char nom[40]);
		void depositar(int m);
		void extraer(int m);
		float retornarMonto();
		void imprimir();
};

class Banco {
	Cliente cliente1, cliente2, cliente3;

	public:
		Banco();
		void operar();
		void depositosTotales();
};

Cliente::Cliente(const char nom[40])
{
	strcpy_s(nombre, nom);
	monto=0;
}

void Cliente::depositar(int m)
{
	monto=monto+m;
}

void Cliente::extraer(int m)
{
	monto=monto-m;
}

float Cliente::retornarMonto()
{
	return monto;
}

void Cliente::imprimir()
{
	cout << "Nombre: " << nombre << " Monto:" << monto << "\n\n";
}

Banco::Banco() :cliente1("juan"), cliente2("pedro"), cliente3("luis")
{

}

void Banco::operar()
{
	cliente1.depositar(100);
	cliente2.depositar(150);
	cliente3.depositar(200);
	cliente3.extraer(150);
}

void Banco::depositosTotales()
{
	float t = cliente1.retornarMonto() + cliente2.retornarMonto() + cliente3.retornarMonto();
	cout << "El total de dinero en el banco es: " << t << "\n\n";
	cliente1.imprimir();
	cliente2.imprimir();
	cliente3.imprimir();
}

int main()
{
	Banco banco1;
	banco1.operar();
	banco1.depositosTotales();
	return 0;
}

Segundo ejemplo:
#include<iostream>
#include<cstdlib>
#include<ctime>

using namespace std;

class Dado{
	int valor;

	public:
		void tirar();
		void imprimir();
		int retornarValor();
};

class JuegoDeDados{
	Dado dado1, dado2, dado3;
	
	public:
		void jugar();
};

void Dado::tirar()
{
	valor=rand()%6+1;
}

void Dado:imprimir()
{
	cout << "Valor del Dado: " << valor << "\n";
}

int Dado::retornarValor()
{
	return valor;
}

void JuegoDeDados::jugar()
{
	dado1.tirar();
	dado1.imprimir();
	dado2.tirar();
	dado2.imprimir();
	dado3.tirar();
	dado3.imprimir();

	if(dado1.retornarValor() == dado2.rerornarValor() && 
		dado1.retornarValor() == dato3.retornarValor())
		{
			cout<<"Gano";
		}
		else
		{
			cout<<"Perdio";
		}
}

int main()
{
	srand(time(NULL));
	JuegoDeDados juego1;
	juego1.jugar();
	return 0;
}
