CONFIGURAR CODE:BLOCKS
Si no compila el framework seguir los siguientes pasos:
1.- Ir al menu "Settings".
2.- Seleccionar la opcion "Compiler...".
3.- En la ventan Compiler settings seleccionar la pestana "Toolchain executables".
4.- Dar clic en el boton "Auto-detect".
5.- En el cuadro de texto cambiara la ruta, algo parecido a: "C:\Program Files(x86)\CodeBlocks\MinGW".

COMPILAR CODIGO EN WINDOWS VS CODE
gcc test.c -o test
gcc test.c -o directory\test

1.- ESTRUCTURA BASICA
2.- IMPRIMIR MENSAJE
3.- VARIABLES
4.- IMPRIMIR VALOR DE VARIABLES
5.- CAPTURAR VALOR DE CONSOLA
6.- OPERADORES
7.- IF
8.- WHILE
9.- DO WHILE
10.- FOR
11.- VECTORES INT Y FLOAT
12.- CHAR
13.- CADENAS DE CARACTERES
14.- FUNCIONES QUE FACILITAN EL TRABAJO CON CADENAS DE CARACTERES (STRING.H)
15.- CONCEPTO DE FUNCIONES - PROGRAMACION ESTRUCTURADA
16.- FUNCIONES CON PARAMETROS DE TIPO INT, FLOAT Y CHAR
17.- FUNCIONES CON RETORNO DE UN VALOR
18.- FUNCIONES CON PARAMETROS DE TIPO VECTOR
19.- VECTORES (MAYOR Y MENOR ELEMENTO)
20.- VECTORES (ORDENAMIENTO)
21.- ESTRUCTURA DE DATOS TIPO MATRIZ (ELEMENTOS INT Y FLOAT)
22.- ESTRUCTURA DE DATOS TIPO MATRIZ (ELEMENTOS CHAR)
23.- VECTORES Y MATRICES PARALELAS (ORDENAMIENTO)
24.- DIRECTIVA #DEFINE
25.- ESTRUCTURA DE DATOS TIPO REGISTRO (STRUCT)
26.- FUNCIONES CON PARAMETROS DE TIPO STRUCT
27.- ESTUCTURA DE DATOS TIPO VECTOR (ELEMENTOS DE TIP STRUCT)
28.- ESTRUCTURA DE DATOS TIPO REGISTRO (CON CAMPOS INT, FLOAT, VECTOR, REGISTROS ANIDADOS, ETC.)
29.- VARIABLES DE TIPO PUNTERO
30.- PARAMETROS DE UNA FUNCION DE TIPO PUNTEROS A INT, FLOAT Y CHAR
31.- PARAMETRO DE UNA FUNCION DE TIPO PUNTEROS A STRUCT
32.- RELACION ENTRE PUNTEROS Y VECTORES
33.- OPERADORES ++ Y -- CON VARIABLES DE TIPO PUNTERO
34.- ASIGNACION DINAMICA DE MEMORIA (MALLOC Y FREE)
35.- RECURSIVIDAD CONCEPTOS BASICOS
36.- RECURSIVIDAD: PROBLEMAS DONDE CONVIENE APLICAR LA RECURSIVIDAD
37.- ESTRUCTURAS DINAMICAS EN C: CONCEPTOS DE ARBOLES
38.- ESTRUCTURAS DINAMICAS EN C: IMPLEMENTACION DE UN ARBOL BINARIO ORDENADO.- TODOS LOS TIPOS DE DATOS PRIMIVTIVOS EN EL LENGUAJE C
39.- TODOS LOS TIPOS DE DATOS PRIMIVTIVOS EN EL LENGUAJE C
40.- OPERADOR DE MOLDE CON TIPOS ENTEROS Y REALIES (CAST)
41.- OPERADORES DE ASIGNACION
42.- OPERADOR CONDICIONAL ?
43.- ESTRUCTURA CONDICIONAL
44.- COMANDOS BREAK Y CONTNUE DENTRO DE ESTRUCTURAS REPETITIVAS
45.- COMANDO GOTO
46.- FUNCION EXIT PARA TERMINAR UN PROGRAMA Y SYSTEM PARA LLAMAR OTRO
47.- DEFINICION DE CONSTANTES (CONST)
48.- EMPLEO DE LLAVES OPCIONALES EN ESTRUCTURAS CONDICIONALES Y REPETITIVAS
49.- DECLARACION DE ENUMERACIONES
50.- DECLARACION DE UNIONES
51.- DEFINICION DE NUEVOS NOMBRES PARA TIPOS DE DATOS EXISTENTES (TYPEDEF)
52.- VARIABLES LOCALES STATIC
53.- APLICACION EN C CON MAS DE UN ARCHIVO FUENTE (PROYECTOS CON MULTIPLES ARCHIVOS)
54.- DEFINICION DE FUNCIONES Y VARIABLES STATIC
55.- VARIABLES GLOBALES CON EL MODIFICADOR EXTERN
56.- MODIFICADOR INLINE EN LA DEFINICION DE FUNCIONES
57.- ARCHIVOS BINARIOS: CREACION Y GRABACION DE TIPO DE DATOS PRIMITIVOS (FOPEN, FWRITE, FCLOSE)
58.- ARCHIVOS BINARIOS: LECTURA DE DATOS PRIMITIVOS (FREAD)
59.- ARCHIVOS BINARIOS: DESPLAZAMIENTO DEL PUNTERO DE ARCHIVO (FSEEK)
60.- ARCHIVO BINARIOS: AGREGAR DATOS
61.- ARCHIVOS BINARIOS: MODIFICAR DATOS
62.- ARCHIVOS BINARIOS: IDENTIFICAR FINAL DE ARCHIVO (FEOF)
63.- ARCHIVOS BINARIOS: POSICION ACTUAL DEL PUNTERO DE ARCHIVO (FTELL)
64.- ARCHIVOS BINARIOS: GRABAR Y LEER VECTORES COMPLETOS EN UN ARCHIVO
65.- ARCHIVO BINARIOS: AGREGAR, CONSULTAR Y MDOIFICAR RESGISTROS (STRUCT) EN UN ARCHIVO
66.- ARCHIVO DE TEXTO: CREACION Y GRABACION DE DATOS
67.- ARCHIVO DE TEXT: LECTURA

.- ESTRUCTURAS DINAMICAS EN C: CONCEPTO DE LISTAS
.- ESTRUCTURAS DINAMICAS EN C: LISTAS TIPO PILA


1.- ESTRUCTURA BASICA
int main(){
	
	return 0;
}

#include<stdio.h>

int main(){

	return 0;
}

2.- IMPRIMIR MENSAJE
Se utiliza la funcion printf("Texto"), esta funcion se encuentra en stdio.h, por eso se debe incluir en el proyecto.

printf("Mensaje");

#include<stdio.h>

int main(){
	printf("Hola mundo!!!");
	
	return 0;
}

3.- VARIABLES
int variableEntera;
variableEntera=1;

int variableEntera=2;

float variableDecimal;
variableDecimal=2.3

float variableDecimal=4.3;

4.- IMPRIMIR VALOR DE VARIABLES
int varInt=1;
float varFloat=1.3;

printf("%i", varInt);
printf("%f", varFloat);

printf("El valor es %i", varInt);
printf("El valor %f sin dividir", varFloat);

printf("%0.2f", varFloar);
Imprimer los solo dos decimales de la variable flotante.

5.- CAPTURAR VALOR DE CONSOLA
Se utiliza la funcion scanf(tipoVariable, &Variable) y se encuentra en stdio.h.

int varInt;

printf("Escribe un valor numerico: ");
scanf("%i", &varInt);

printf("%i", varInt);

getchar();

Para detener el proceso para ver el resultado se debe utilizar getchar(), que tambien se encuentra en stdio.h. Tambien se puede utilizar getch(), pero se debe incluir conio.h.
#include<stdio.h>
#include<conio.h>

6.- OPERADORES
Operadores matematicos
+	suma
-	resta
*	multiplicacion
/	divicion
%	resto de la divicion

Operadores relacionales
>	mayor que
<	menor que
>=	mayor o igual que
<=	menor o igual que
==	igual que
!=	diferente que

Operadores logicos
&&	y
||	o

7.- IF
if(a == b){

}

if(a != b){

}
else {

}

if (a == b){

}
else if (b <= c) {

}
else {

}

if (a == b){
	if (b == c){
	
	}
}
else {
	if(a > b){
	
	}
	else {
	
	}
}

8.- WHILE
int varInt=0;

while(varInt != 10){
	printf("%i", varInt);
	varInt=varInt+1;
}

9.- DO WHILE
int varInt=0;

do{
	printf("Escribe un numero: ");
	scanf("%i", &varInt);
} while(varInt == 1);

10.- FOR
int varInt=0;

for(varInt=0; varInt<=10; varInt++){
	printf("%i", varInt);
}

for(int x=0; x<=10; x++){
	printf("%i", x);
}

11.- VECTORES INT Y FLOAT
int vecInt[10];
float vecFloat[5];

for(int x=0; x<10; x++){
	printf("Ingrese valor: ");
	scanf("%i", &vecInt[x]);
}

for(int x=0; x<10; x++){
	print("%i", &vecInt[x]);
	print("\n");
}

Inicializar
int vec[3]={10, 20, 30};

12.- CHAR
char varChar='a';
varChar=65; //En ASCII es la letra A

printf("Ingrese una letra: ");
scanf(" %c", &varChar);

printf("%c", varChar);

if (varChar == 's'){

}

char letra;

for(letra='A'; letra<='Z'; letra++){
	printf("%c", letra);
	printf("-");
}

for(letra='a'; letra<='z'; letra++){
	printf("%c", letra);
	printf("-");
}

13.- CADENAS DE CARACTERES
char vecChar[16]="Pablo Rodriguez";

printf("%s", vecChar);

El tamano 16 no es un capricho, si contamos la cantidad de caracteres que hay entre las comillas incluyendo el espacio en blanco veremos que es 15. Luego recordar que debe haber un caracter extra en el vector donce se indica que ahi finalizan los datos de la cadena. No hay problema si el vector reserva mas de 16 caracteres, en cambio se generaran errores inesperados si el vector tiene menos de 16 caracteres.

Componente	[0]	[1]	...	[15]
vecChar		'p'	'a'	...	'\0'

En memoria se almacenan en cada posicion del vector el caracter respectivo y cuando se ejecuta el programa y se muestran los datos mediante la funcion printf se muestran todos hasta que encuentra el caracter NULL que coincide con el caracgter ASCII 0.

char vecChar[16]="Pablo";

componente	[0]	[1]	[2]	[3]	[4]	[5]	[6]	... [15]
vecChar		'p'	'a'	'b'	'l'	'0'	'\0' ''	...	''

Para cargar por teclado una cadena de caracteres debemos emplear por ahora la funcion gets.

gets(nombre del vector);

char nombre1[21];
char nombre2[21];
int edad1;
int edad2;

printf("Ingrese el nombre de la primera persona: ");
gets(nombre1);

printf("Ingrese la edad: ");
scanf("%i", &edad1);

fflush(stdin);

printf("Ingrese el nombre de la segunda persona: ");
gets(nombre2);

printf("Ingrese la edad: ");
scanf("%i", &edad2);

char palabra[30];
int x=0;
int cant=0;

while (palabra[x] != '\0'){
	if(palabra[x] == 'a'){
		cant++;
	}
	x++;
}

14.- FUNCIONES QUE FACILITAN EL TRABAJO CON CADENAS DE CARACTERES (STRING.H)
#include<string.h>

strlen

int cant=strlen(varChar);

strcmp

int strcmp(cadena1, cadena2)

if(strcmp(nombre1, nombre0) == 0){

}

Retorna un cero si las dos cadenas son exactamente iguales.
Retorna un valor mayor a cero si la cadena1 es mayor alfabeticamente que la segunda.
Retorna un valor menor a cero si la cadena2 es mayor alfabeticamente que la primera.

strcpy

strcpy(cadena1, cadena2);
Si en un problema necesitamos dejar un string vacio podemos utilizar la funcion strcpy pasando un string sin caracteres (no debe haber un espacio en blanco):

strcpy(cadena, "");

strcat
Si necesitamos agregar a un string otro string podemos utilizar la funcion strcat.

strcat(cadena1, cadena2);

15.- CONCEPTO DE FUNCIONES - PROGRAMACION ESTRUCTURADA
Estructura de una funcion:

[valor que retorna] [nombre de la funcion] ([parametros de la funcion]){
	[algoritmo]
}

void presentacion(){
	printf("HOLA!!!\n");
}

void cargarNumero(){
	int valor;
	
	printf("Ingrese un valor: ");
	scanf("%i", &valor);
	printf("El valor es: %i", valor);
}

int main(){
	presentacion();
	cargarNumero();
	
	getch();
	
	return 0;
}

16.- FUNCIONES CON PARAMETROS DE TIPO INT, FLOAT Y CHAR
void funcion1(int v1){
	...
}

void funcion2(int v1, int v2){
	...
}

void funcion3(float f1, int v1){
	...
}

void funcion4(char letra){
	...
}


#include<stdio.h>
#include<conio.h>

void imprimirMayor(int v1, int v2){
	if (v1>v2){
		print("El mayor es %i", v1);
	}
	else {
		printf("El mayor es %i", v2);
	}
}

int main(){
	int valor1, valor2;
	
	printf("Ingrese primer valor: ");
	scanf("%i", &valor1);
	
	printf("Ingrese segundo valor: ");
	scanf("%i", &valor2);
	
	imprimirMayor(valor1, valor2);
	
	getch();

	return 0;
}

17.- FUNCIONES CON RETORNO DE UN VALOR
int funcion1(){
	return 1;
}

float funcion2{
	return 3.1415;
}

char funcion3{
	return 'a';
}

#include<stdio.h>
#include<conio.h>

int retornarMayor(int v1, int v2){
	int mayor;

	if (v1>v2){
		mayor=v1;
	}
	else {
		mayor=v2;
	}
	
	return mayor;
}

int main(){
	int valor1, valor2;
	
	printf("Ingrese primer valor: ");
	scanf("%i", &valor1);
	
	printf("Ingrese segundo valor: ");
	scanf("%i", &valor2);
	
	printf("El valor mayour es %i", retornarMayor(valor1, valor2));
	
	getch();

	return 0;
}

18.- FUNCIONES CON PARAMETROS DE TIPO VECTOR
Cuando un vector se pasa como parametro a una fucnion no se hace una copia como sucede con los tipos de dato char, int, float sino se pasa la direccion de memoria donde se almacena el vector original. Esta forma de pasaje de datos tipo vector hace que si modificamos el parametro dentro de la funcion lo que sucede es que se modifica la variable definida en la funcion main o donde se haya definido.

void funcion1(int vec[5]){
	...
}

int vector[5];
funcion1(vector);

#include<stdio.h>
#include<conio.h>

void cargar(int vec[5]){
	int x;
	
	for(x=0; x<5; x++){
		printf("Ingrese elemento: ");
		scanf("%i", &vec[x]);
	}
}

void imprimir(int vec[5]){
	int x;
	
	printf("Contnido completo del vector:");
	
	for(x=0; x<5; x++){
		printf("%i", vec[x]);
	}
}

int main(){
	int vector[5];
	
	cargar(vector);
	imprimir(vector);
	
	getch();
	
	return 0;
}

19.- VECTORES (MAYOR Y MENOR ELEMENTO)
Cargar e imprimir el mayor elemento y su posicion.

#include<stdio.h>
#include<conion.h>

void cargar(int vector[5]){
	int x;
	
	for(x=0; x<5; x++){
		printf("Ingrese elemento:");
		scanf("%i", &vector[x]);
	}
}

void mayor(int vector[5]){
	int may=vector[0];
	int pos=0;
	int x;
	
	for(x=1; x<5; x++){
		if(vector[x]>may){
			may=vector[x];
			pos=x;
	}
	
	printf("Mayor elemento del vector: %i\n", may);
	printf("Se encuentra en la posicion: %i", pos);
}

int main(){
	int vector[5];
	
	cargar(vector);
	mayor(vector);
	
	getch();
	return 0;
}

Cargar, imprimir el menor y un mensaje si se repite dentro del vector.

#include<stdio.h>
#include<conio.h>

void cargar(int vector[5]){
	int x;
	
	for(x=0; x<5; x++){
		printf("Ingrese elemento: ");
		scanf("%i", &vector[x]);
	}
}

int menor(int vector[5]){
	int men=vector[0];
	int x;
	
	for(x=1; x<5; x++){
		if(vector[x]<men){
			men=vector[x];
		}
	}
	
	return men;
}

void verificarRepite(int vector[5], int men){
	int cant=0;
	int x;
	
	for(x=0; x<5; x++){
		if(vector[x]==men){
			cant++;
		}
	}
	
	if(cant==1){
		printf("El menor del vector no se repite.");
	}
	else {
		printf("El menor del vector se repite.");
	}
}

int main(){
	int vector[5];
	
	cargar(vector);
	
	int men=menor(vector);
	
	printf("El elemento menor del vector es: %i\n", men);
	
	verificarRepite(vector, men);
	
	getch();
	
	return 0;
}

20.- VECTORES (ORDENAMIENTO)

#include<stdio.h>
#include<conio.h>

void cargar(int vector[5]){
	int x;
	
	for(x=0; x<5; x++){
		printf("Ingrese elemento: ");
		scanf("%i", &vector[x]);
	}
}

void ordenarMenorMayor(int vector[5]){
	int k, f;
	
	for(k=0; k<4; k++){
		for(f=0; f<4-k; f++){
			if(vector[f]>vector[f+1]){
				int aux;
				aux=vector[f];
				vector[f]=vector[f+1];
				vector[f+1]=aux;
			}
		}
	}
}

void ordenarMayorMenor(int vector[5]){
	int k, f;
	
	for(k=0; k<4; k++){
		for(f=0; f<4-k; f++){
			if(vector[f]<vector[f+1]){
				int aux;
				aux=vector[f];
				vector[f]=vector[f+1];
				vector[f+1]=aux;
			}
		}
	}
}

void imprimir(int vector[5]){
	int x;
	
	for(x=0; x<5; x++){
		printf("%i", vector[x]);
	}
}

int main(){
	int vector[5];
	
	cargar(vector);
	ordenarMenorMayor(vector);
	
	printf("Ordenado de menor a mayor\n");
	
	imprimir(vector);
	
	ordenarMayorMenor(vector);
	
	printf("Ordenar de mayor a menor\n");
	
	imprimir(vector);
	
	getch();
	return 0;
}

21.- ESTRUCTURA DE DATOS TIPO MATRIZ (ELEMENTOS INT Y FLOAT)

int mat[fila][columna];
int mat[3][5];

Inicializar
int mat[2][3]={{10, 20, 30},
				{40, 50, 50}};

for(int f=0; f<3; f++){
	for(int c=0; c<5; c++){
		printf("Ingrese componentes: ");
		scanf("%i", &mat[f][c]);
	}
}

for(int f=0; f<3; f++){
	for(int c=0; c<5; c++){
		printf("%i", mat[f][c]);
	}
}

Imprimir en diagonal

int mat[4][4];

for(int x=0; x<4; x++){
	printf("%i", mat[x][x]);
}

Imprimir valor mayor

void mayor(int mat[3][4]){
	int may=mat[0][0];
	
	for(int f=0; f<3; f++){
		for(int c=0; c<4; c++){
			if(mat[f][c]>may){
				may=mat[f][c];
			}
		}
	}
	
	printf("Elemento mayor de la matriz: %i", may);
}

Intercambiar filas
void intercambiarFilas(int mat[2][5]){
	int aux;
	
	for(int c=0; c<5; c++){
		aux=mat[0][c];
		mat[0][c]=mat[1][c];
		mat[1][c]=aux;
	}
}

22.- ESTRUCTURA DE DATOS TIPO MATRIZ (ELEMENTOS CHAR)
Las matrices de tipo dato char se utilizan fundamentalmente para guardar un conjunto de cadenas de caracteres (varios nombres de personas, nombres de articulos, etc.).

Cuando trabajamos una matriz de tipo char para almacenar cadenas de caracteres cada fila almacena un string.

Para trabajar una matriz de tipo char se parece a trabajar con un vector, debemos indicar una solo subindice y estaremos accediendo a toda la fila.

void cargar(char articulos[3][31]){
	for(int x=0; x<3; x++){
		printf("Ingrese el nombre del articulos: ");
		gets(articulos[x]);
	}
}

void imprimir(char articulos[3][31]){
	for(int x=0; x<3; x++){
		printf("%s\n", articulos[f]);
	}
}

char nom[30];
char nom[5][30];
int existe;

for(int x=0; x<5; x++){
	if(strcmp(nom, nombres[f]) == 0){
		existe=1;
	}
}

void ordenar(char nombres[4][41]){
	char aux[41];
	
	for(int x=0; x<4; x++){
		for(int y=0; y<4-x; y++){
			if(strcmp(nombres[y], nombres[y+1])>0){
				strcpy(aux, nombres[y]);
				strcpy(nombres[y], nombres[y+1]);
				strcpy(nombres[y+1], aux);
			}
		}
	}
}

23.- VECTORES Y MATRICES PARALELAS (ORDENAMIENTO)

void cargar(char nombres[5][40], int notas[5]){
	for(int x=0; x<5; x++){
		printf("Ingrese el nombre del alumno: ");
		gets(nombres[f]);
		
		printf("Ingrese la nota del alumno: ");
		scanf("%i", &notas[f]);
		fflush(stdin);
	}
}

void ordenar(char nombres[5][60], int notas[5]){
	int auxnotas;
	char auxnombre[40];
	
	for(int k=0; k<4; k++){
		for(int f=0; f<4-k; f++){
			if(notas[f]<notas[f+1]){
				auxnotas=notas[f];
				notas[f]=notas[f+1];
				notas[f+1]=auxnota;
				strcpy(auxnombre, nombres[f]);
				strcpy(nombres[f], nombres[f+1]);
				strcpy(nombres[f+1], auxnombre);
			}
		}
	}
}

void imprimir(char nombres[5][40], int notas[5]){
	for(int x=0; x<5; x++){
		printf("%s - %i\n", nombres[f], notas[f]);
	}
}

24.- DIRECTIVA #DEFINE
La directiva #define especifica un nombre que sera reemplazado por un cierto valor en todods los lugares del programa donde se haga referencia a dicho nombre.

Se crean fuera de cualquier funcion normalmente en la parte inicial del archivo luego de las directivas #include. La sintaxis es la siguiente:

#define [nombre de la macro] [valor de la macro]

#define TAMANO 20
#define MENSAJEFIN "Presione una tecla para finalizar"

El nombre de la macro es comun que se lo escriba con caracteres mayusculas (es una regla que utilizan muchos programadores pero no es obligatoria).

Luego de espicificar el nombre de la macro hay uno o mas espacios en blanco y debemos especificar el valor de la macro.

El primer paro del compilador es reemplazar todas las partes del programa donde hay declaradas macros por los valores de dichas macros.

El uso excesivo de macros puede tornar muy dificil el mantenimiento de programas.

#define TAMANO 5
#define FINPROGRAMA "Gracias por utilizar nuestro programa"

void cargar(float sueldos[TAMANO]){
	for(int f=0; f<TAMANAO; f++){
		printf("Ingrese sueldo: ");
		scanf("%f", &sueldos[f]);
	}
	
	printf(FINPROGRAMA);
}

25.- ESTRUCTURA DE DATOS TIPO REGISTRO (STRUCT)

Un registro es una estructura de datos que permite almacenar un conjunto de lementos no ecensialmente del mismo tipo.

Vimos que vectores y matrices son estructuras de datos que permiten almacenar un conjunto de datos del mismo tipo. Un registro normalmente almacena un conjunto de datos que estan relacionados entre si.

A un vector o matriz accedemos a sus elementos por medio de subindices, a los elmentos de un registro se los llama campos y tienen cada uno un nombre. Por ejemplo si definimos el registro "producto" sus campos pueden ser el "codigo", "descripcion" y "precio".

A diferencia de vectores y matrices los registros deben declararse y luego definir variables de dicho tipo. Pero si solo declaramos el registro no nos sirve de nada, debemos definir una o mas variables de dicho tipo.

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
};

#include<stdio.h>
#include<conio.h>

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
};

int main(){
	struct producto pro1, pro2;
	
	printf("Ingrese el codigo del producto: ");
	scanf("%i", &pro1.codigo);
	fflush(stdin);
	
	printf("Ingrese la descripcion: "):
	gets(pro1.descripcion);
	
	printf("Ingrese el precio: ");
	scanf("%f", &pro1.precio);
	
	printf("Ingrese el codigo del producto: ");
	scanf("%i", &pro2.codigo);
	fflush(stdin);
	
	printf("Ingrese la descripcion: "):
	gets(pro2.descripcion);
	
	printf("Ingrese el precio: ");
	scanf("%f", &pro2.precio);
	
	if(pro1.precio>pro2.precio){
		printf("El producto %s tiene un precio mayo.", pro1.descripcion);
	}
	else{
		if(pro2.precio>pro1.precio){
			printf("El producto %s tiene un precio mayor", pro2.descripcion);
		}
		else{
			printf("Tienen igual precio");
		}
	}
	
	getch();
	
	return 0;
}

26.- FUNCIONES CON PARAMETROS DE TIPO STRUCT
Su funcionamiento es identico a los tipos de datos simples, es decir que se hace una copia del registro en el parametro. No podemos modificar el registro que le enviamos a la funcion sino solo accederlo para consultarlo.

#include<stdio.h>
#include<conio.h>
#include<string.h>

struct producto {
	int codigo;
	char descripcion[41];
	float precio;
};

void imprimir(struct producto p){
	printf("Codigo del producto: %i\n", p.codigo);
	printf("Descripcion: %s\n", p.descripcion);
	printf("Precio: %0.2f", p.precio);
}

int main(){
	struct producto pro;
	
	pro.codigo=1;
	strcpy(pro.descripcion, "naranjas");
	pro.precio=12.50;
	
	imprimir(pro);
	
	getch();
	
	return 0;
}

27.- ESTUCTURA DE DATOS TIPO VECTOR (ELEMENTOS DE TIP STRUCT)
#include<stdio.h>
#include<conio.h>

#define TAMANO 4

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
};

void cargar(struct producto vec[TAMANO]){
	for(int f=0; f<TAMANO; f++){
		printf("Ingrese el codigo del prodcuto: ");
		scanf("%i", &vec[f].codigo);
		fflush(stdin);
		
		printf("Ingrese la descripcion: ");
		gets(vec[f].descripcion);
		
		printf("Ingrese el precio: ");
		scanf("%f", &vec[f].precio);
	}
}

void imprimir(struct producto vec[TAMANO]){
	for(int f=0; f<TAMANO; f++){
		printf("%i %s %0.2f\n", vec[f].codigo, vec[f].descripcion, vec[f].precio);
	}
}

int main(){
	struct producto vector[TAMANO];
	cargar(vector);
	imprimir(vector);
	
	getch();
	
	return 0;
}

28.- ESTRUCTURA DE DATOS TIPO REGISTRO (CON CAMPOS INT, FLOAT, VECTOR, REGISTROS ANIDADOS, ETC.)
En este concepto veremos que los campos de un registro pueden ser tambien de tipo registro, es decir anidar un registro dentro de otro registro.

struct fecha{
	int dd;
	int mm;
	int aa;
};

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
	struct fecha fechavencimiento;
};

void cargar(struct producto vec[3]){
	for(int f=0; f<3; f++){
		printf("Ingrese codigo del producto: ");
		scanf("%i", &vec[f].codigo);
		fflush(stdin);
		
		prinft("Ingrese descripcion: ");
		get(vec[f].descripcion);
		
		printf("Ingrese precio: ");
		scanf("%f", &vec[f].precio);
		
		printf("Fecha de vencimiento.\n");
		printf("Dia: ");
		scanf("%i", &vec[f].fechavencimiento.dd);
		
		printf("Mes: ");
		scanf("%i", &vec[f].fechavencimiento.mm);
		
		printf("Anio: ");
		scanf("%i", &vec[f].fechavencimiento.aa);
	}
}

void imprimirt(struct producto vec[3]){
	for(int f=0; f<3; f++){
		printf("%i %s %0.2f %i/%i/%i\n", vec[f].codigo, vec[f].descripcion, vec[f].precio, vec[f].fechavencimiento.dd, vec[f].fechavencimiento.mm, vec[f].fechavencimiento.aa);
	}
}

29.- VARIABLES DE TIPO PUNTERO
Los punteros en el lenguaje C son esenciales:
Para que un programa sea muy eficiente.
Modificar variables de tipo int, float, struct, etc. en otras funciones.
Poder requerir y liberar memoria durante la ejecucion del programa (hay muchas situaciones donde no sabemos cuanto espacio reservar).

Definicion de puntero.
Una variable de tipo funtero almacena la direccion de memoria de otra varaible que puede ser int, char, float, struct, etc.

int valor1=10;
int valor2=20;
int *pe;

pe=&valor1;
printf("Lo apuntado por pe es: %i\n", *pe);
printf("La direccion que almacena pe es: %p\n", pe);

pe=&valor2;
printf("Lo apuntado por pe es: %i\n", *pe);
prinrf("La direccion que almacena pe es: %p\n", pe);

getch();
return 0;

int x1, x2;
int *pe;

pe=&x1;
*pe=100;

pe=&x2;
*pe=200;

printf("Primer variable entera: %i\n", x1);
printf("Segunda variable entera: %i\n", x2);

char c1='A';
char c2='B';
char *pc;

pc=&c1;
printf("%c\n", c1); //se imprime: A

*pc='a';
printf("%c\n", c1); //se imprime: a

c1='Z';
printf("%c\n", *pc); //se imprime: Z

pc=&c2;
printf("%c\n", *pc); //se imprime: B

int f;
int *pe;
pe=&f;

for(*pe=1; *pe<=10; *pe=*pe+1){
	pirntf("%i\n", f):
}

30.- PARAMETROS DE UNA FUNCION DE TIPO PUNTEROS A INT, FLOAT Y CHAR
Hemos visto que cuando llamamos a una funcion y le pasamos un tipo de dato char, int o float lo que sucede es que se hace una copia de dicha variable en el parametro de la funcion.

Ahora veremos el primer uso real de punteros en el lenguaje C. Cuando unos quiere modificar una variable char, int, float en una funcion lo que hacemos es pasar la direccion de la variable y que lo reciba un puntero.

void cargar(int *pe1, int *pe2){
	*pe1=100;
	*pe2=200;
}

int main(){
	int x1, x2;
	
	cargar(&x1, &x2);
	
	printf("%i %i", x1, x2);
	
	getch();
	
	return 0;
}

Importante:
Despues de mucho avanzar en este curso del lenguaje C podemos entender completamente porque es la siguiente sintaxis para cargar un entero por teclado:

int x1;
scanf("%i", &x1);

El & significa que le pasamos la direccion de al variable x1 para que la funcion por medio de un puntero cargue un entero en x1.

void incrementar(int *pe){
	*pe=*pe+1;
}

int main(){
	int x=0;
	
	print("%i\n", x);
	
	incrementar(&x);
	
	printf("%i\n", x);
	
	getch();
	
	return 0;
}

31.- PARAMETRO DE UNA FUNCION DE TIPO PUNTEROS A STRUCT
Vimos  que cuando pasamos una variable de tipo registro a una funcion lo que sucede es que se hace una copia en el parametro.

Ahora veremos que si queremos modificar el registro en la funcion lo que debemos hacer es pasar la direccion del registro y que lo reciba un puntero.

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
}

void cargar(struct producto *pprod){
	printf("Ingrese codigo: ");
	scanf("%i", &(*pprod).codigo);
	fflush(stdin);
	
	printf("Ingrese descripcion: ");
	gets((*pprod).descripcion);
	
	printf("Ingrese precio: ");
	scanf("%f", &(*pprod).precio);
}

void imprimir(struct producto prod){
	printf("Codigo:%i\n", prod.codigo);
	printf("Descripcion:%s\n", prod.descripcion);
	printf("Precio:%0.2f", prod.precio);
}

int main(){
	struct producto prod;
	
	cargar(&prod);
	imprimir(prod);
	
	getch();
	
	return 0;
}

Importante
Si bien en el lenguaje C podemos utilizar para acceder a los campos del registro la sintaxis anterior es mucho mas comun utilizar el operador -> para acceder a los campos.

void cargar(struct producto *pprod){
	printf("Ingrese codigo: ");
	scanf("%i", &pprod->codigo);
	fflush(stdin);
	
	printf("Ingrese descripcion: ");
	gets(pprod->descripcion);
	
	printf("Ingrese precio: ");
	scanf("%f", &pprod->precio);
}

32.- RELACION ENTRE PUNTEROS Y VECTORES
Es importante entender que un vector es un puntero que contiene la direccion de la primera componente.

int vec[5]={10, 20, 30, 40, 50};
int *pe;

Si luego igualamos pe con vec:

pe=vec;

La variable pe almacena la misma direccion de memoria que la variable vec. Ahora podemos trabajar perfectamente con la variable pe para acceder a las componentes del vector.

void cargar (float *p){
	for(int f=0; f<5; f++){
		printf("Ingrese elemento: ");
		scanf("%f", &p[f]);
	}
}

void imprimir(float *p){
	for(int f=0; f<5; f++){
		printf("%0.2f",  p[f]);
	}
}

int main(){
	float vec[5];
	
	cargar(vec);
	imprimir(vec);
	
	getch();
	
	return 0;
}

33.- OPERADORES ++ Y -- CON VARIABLES DE TIPO PUNTERO
Los operadores ++ y -- con tipo de dato puntero tienen un funcionamiento distinto que cuando incrementamos o decrementamos una variable entera.

Cuando utilizamos el operador ++ con un puntero incrementa la variable segun el tamano del tipo de dato que apunta. Si es un puntero a entero incrementa la direccion a 4 bytes (en un sistema operativo de 32 bits), si es un puntero a tipo char incrementa la direccion en 1 byte etc.

int main(){
	int vec[5]={10, 20, 30, 40, 50};
	int *pe;
	
	pe=vec;
	
	printf("%i\n", *pe); //10
	pe++;
	printf("%i\n", *pe); //20
	pe++;
	printf("%i\n", *pe); //30
	pe--;
	printf("%i\n", *pe); //20
	
	getch();
	
	return 0;
}

void cargar(int *pe){
	for(int f=0; f<5; f++){
		printf("Ingrese elemento: ");
		scanf("%i", &*pe);
		pe++;
	}
}

void imprimir(int *pe){
	for(int f=0; f<5; f++){
		printf("%i ", *pe);
		pe++;
	}
}

int main(){
	int vec[5];
	
	cargar(vec);
	imprimir(vec);
	
	getch();
	
	return 0;
}

34.- ASIGNACION DINAMICA DE MEMORIA (MALLOC Y FREE)
Una caracteristica esencial del lenguaje C es la capacidad de requerir bloques de memoria variable durante la ejecucion del programa.

Hasta ahora hemos visto que se reserva espacio para variables en el momento que las definimos:

int x;

El lenguaje C nos permite en tiempo de ejecucion solicitar espacio mediante la funcion malloc (memory allocate = asignar memoria) y luego de usarla en forma obligada debemos devolverla llamando a la funcion free. Estas dos funciones se encuentran en el archivo de inclusion: stdlib.h

Para trabajar con la memoria dinamica en el lenguaje C es obligatorio trabajar con punteros.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main(){
	int *pe;
	int tam;
	
	printf("Cuantos elementos tendra el vector: ");
	scanf("%i", &tam);
	
	pe=malloc(tam*sizeof(int));
	
	for(int f=0; f<tam; f++){
		printf("Ingrese elemento: ");
		scanf("%i", &pe[f]);
	}
	
	printf("Contenido del vector dinamico: ");
	
	for(int f=0; f<tam; f++){
		printf("%i ", pe[f]);
	}
	
	free(pe);
	getch();
	return 0;
}

El operador sizeof cuando le pasamos como parametro un tipo de dato lo que nos devuelve es la cantidad de bytes que se requieren para almacenar dicho tipo de dato. Si compilamos nuestro programa en un compilador de 32 bits luego un int requiere 4 bytes. Finalmente multiplicamos lo que retorna sizeof por el contenido de l variable tam, cuyo resultado es la cantidad de bytes que se necesitan reservar para un vector de tam elementos.

#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<stdlib.h>

struct producto{
	int codigo;
	char descripcion[41];
	float precio;
}

int main(){
	struct producto *prod;
	
	prod=malloc(sizeof(struct producto));
	
	prod->codigo=1;
	strcpy(prod->descripcion, "papas");
	prod->precio=10.50;
	
	printf("Codigo del articulo:%i\n", prod->codigo);
	printf("Descripcion:%s\n", prod->descripcion);
	printf("Precio:%0.2f", prod->precio);
	
	free(prod);
	
	getch();
	
	return 0;
}

35.- RECURSIVIDAD CONCEPTOS BASICOS
Primero debemos decir que la recursividad no es una esctructura de datos, sino que es una tecnica de programacin que nos permite que un bloque de instrucciones se ejecute n veces. Remplaza en ocasiones a esctructuras repetitivas.

Este concepto sera de gran utilidad para los conceptios de la estructura de datos tipo arbol.

En C las funciones pueden llamarse a si mismos. Si dentro de una funcion existe la llamada a si mismo decimos que la funcion es recursiva.

Cuando una funcion se llama asi misma, se asigna espacio en la pila para las nuevas variables locales y parametros.

Al volver de una llamada recursiva, se recuperan de la pila las variables locales y los parametros antiguos y la ejecucion se reanuda en el punto de la llamada a la funcion.

#include<stdio.h>
#include<conio.h>

void repetir(){
	repetir();
}

int main(){
	repetir();
	getch();
	return 0;
}

La funcion repetir es recursiva porque dentro de la funcion se llama a si misma. Cuando ejecuta este programa se bloqueata y generara una error.

#include<stdio.h>
#include<conio.h>

void imprimir(int x){
	printf("%i", x);
	imprimir(x-1);
}

int main(){
	imprimir(5);
	getch();
	return 0;
}

Desde la main se llama a la funcion imprimir y se le envia el valor 5. El parametro x recibe el valor 5. Se ejecuta el algoritmo de la funcion, imprime el contenido del parametro (5) y seguidamente se llama a una funcion, en este caso a si misma (por eso decimos que es una funcion recursiva), enviandole el valor 4.

El parametro x recibe el valor 4 y se imprime en pantalla el cuatro, llamando nuevamente a la funcion imprimir enviandole el valor 3. Si continuamos este algoritmo podremos observar que en pantalla se imprime:

5 4 3 2 1 0 -1 -2 -3 ...

hasta que se bloquee el programa.

Tener en cuenta que cada llamada a una funcion consume 4 bytes por la llamada y en este caso 4 bytes por el parametro x. Como nunca finaliza la ejecucion completa de las funciones se desborda la pila estatica por las sucesivas llamadas.

#include<stdio.h>
#include<conio.h>

void imprimir(int x){
	if(x>0){
		printf("%i", x);
		imprimir(x-1);
	}
}

int main(){
	imprimir(5);
	getch();
	return 0;
}

Ahora si podemos ejecutar este programa y observar los resultados en pantalla. Se imprime los numeros 5 4 3 2 1 y no se bloquea el programa.

Obtener el factorial de un numero

#include<stdio.h>
#include<conio.h>

int factorial(int fact){
	if(fact>0){
		int valor=fact*factorial(fact-1);
		return valor;
	} else {
		return 1;
	}
}

int main(){
	printf("El factorial de 4 es %i", factorial(4));
	getch();
	return 0;
}

Ordenar los elementos de un vector

void ordernar(int vec[CANTIDAD], int cant){
	if(cant>1){		
		for(int f=0; f<cant-1; f++){
			if(vec[f]>vec[f+1]){
				if(vec[f]>vec[f+1]){
					int aux=vec[f];
					vec[f]=vec[f+1];
					vec[f+1]=aux;
				}
			}
		}
		
		ordenar(vec, cant-1);
	}
}

36.- RECURSIVIDAD: PROBLEMAS DONDE CONVIENE APLICAR LA RECURSIVIDAD
Imprimir la informacion de una lista simplemente encadenada de atras para adelante.
El empleo de estructuras repetitivas para resolver este problema es bastante engorroso y lento (debemos avanzar hasta el ultimo nodo e imprimir, luego avanzar desde el principio hasta el anteultimo nodo y asi sucesivamente).

El empleo de la recursividad para este problema hace mas sencilla su solucion.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

struct nodo{
	int info;
	struct nodo *sig;
};

struct nodo *raiz=NULL;

void insertarPrimero(int x){
	struct nodo *nuevo;
	nuevo=malloc(sizeof(struct nodo));
	nuevo->info=x;
	nuevo->sig=raiz;
	raiz=nuevo;
}

void imprimir(struct nodo *reco){
	if(reco!=NULL){
		imprimir(reco->sig);
		printf("%i ", reco->info);
	}
}

void liberar(){
	struct nodo *reco=raiz;
	struct nodo *bor;
	
	while(reco!=NULL){
		bor=reco;
		reco=reco->sig;
		free(bor);
	}
}

int main(){
	insertarPrimero(10);
	insertarPrimero(4);
	insertarPrimero(5);
	
	printf("Impresion de la lista del final al principio.\n");
	
	imprimir(raiz);
	
	liberar();
	
	getch();
	
	return 0;
}

37.- ESTRUCTURAS DINAMICAS EN C: CONCEPTOS DE ARBOLES
Igual que la lista, el arbol es una estructura de datos. Son muy eficientes para la busqueda de informacion. Los arboles soportan estructuras no lineales.

				A
			/	|	\
			B	C	D
		/	|
		E	F

Algunos conceptos de la estructura de datos tipo arbol:
Nodo hoja: Es un nodo sin descendientes (Nodo terminal)
Nodo E, F, C y D.

Nodo interior: Nodo que no es hoja.
Nodo A y B.

Nivel de un arbol: El nodo A esta en el nivel 1 sus descendientes directos estan en el nivel 2 y asi sucesivamente. El nivel del arbol esta dado por el nodo de maximo nivel.
Este arbol es de nivel 3.

Grado de un nodo: Es el numero de nodos hijos que tiene dicho nodo (solo se tiene en cuenta los nodos interiores). El nodo A tiene grado 3. El nodo B tiene grado 2.
Los otros nodos no tienen grado porque no tienen descendientes.

Grado de un arbol: Es el maximo de los grados de todos los nodos de un arbol.
El grado del arbol es 3.

Longitud de camino del nodo x: Al numero de arcos que deben ser recorridos para llegar a un nodo x, partiendo de la raiz. La raiz tiene longitud de camino 1, sus descendientes directos tienen longitud de camino 2, etc. En forma general un nodo en el nivel tiene longitud de camino i.

Arbol binario: Un arbol binario si cada nodo tiene como maximo 2 descendientes.

			A
		/		\
		B		C
	/	|			\
	D	E			F
	
Para cada nodo esta definido el subarbol izquierdo y el derecho.

Para el nodo A el subarbol izquierdo esta constituido por los nodos B, D y E. Y el subarbol derecho esta formado por los nodos C y F. 

Lo mismo para el nodo B tiene el subarbol izquierdo con un nodo (D) y un nodo en el subarbol derecho (E).

El nodo D tiene ambos subarboles vacios.

El nodo C tiene el subarbol izquierdo vacio y el subarbol derecho con un nodo (F).

Arbol binario perfectamente equilibrado: Si para cada nodo el numero de nodos en el subarbol izquierdo y el numero de nodos en el subarbol derecho, difiere como mucho en una unidad.

Hay qeu tener en cuenta todos los nodos del arbol.

El arbol de mas arriba es perfectamente equilibrado.

Arbol que no es perfectamente equilibrado:
El nodo A tiene 3 nodos en el subarbol izquierdo y solo uno en el subarbol derecho, por lo que no es perfectamente equilibrado.

				A
			/		\
			B		C
		/	|
		D	E

Arbol binario completo: Es un arbol binario con hojas como maximo en los niveles n-1 y n (Siendo n el nivel del arbol).

Los dos arboles graficados son complejos por que son arboles de nivel 3 y hay nodos hoja en el nivel 3 en el primer caso, y hay nodos hoja en los niveles 3 y 2 en el segundo caso.

Arbol binario no completo

				A
			/		\
			B		C
		/	|
		D	E
				\
				F

Hay nodos hoja en los niveles 4, 3 y 2. No deberia haber nodos hojas en el nivel 2.

Arbol binario ordenado: Si para cada nodo del arbol, los nodos ubicados a la izquierda son inferiores al que consideramos raiz para ese momento y los nodos ubicados a la derecha son mayores que la raiz.

				50
			/		\
			25		70
		/	|
		8	30
		
Analicemos si se trata de un arbol binario ordenado:
Para el nodo que tiene el 50:
Los nodos del subarbol izquierdo son todos menores a 50? 8, 25, 30 si
Los nodos del subarbol derecho son todos mayores a 50? 70 si

Para el nodo que tiene el 25:
Los nodos del subarbol izquierdo son todos menores a 25? 8 si
Los nodos del subarbol derecho son todos mayores a 25? 30 si

No hace falta analizar los nodos hoja. Si todas las respuestas son afirmativas podemos luego decir que se trata de un arbol binario ordenado.

38.- ESTRUCTURAS DINAMICAS EN C: IMPLEMENTACION DE UN ARBOL BINARIO ORDENADO
Desarrollar un programa para la administracion de un arbol binario ordenado con informacion de tipo int.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

struct nodo{
	int info;
	struct nodo *izq;
	struct nodo *der;
};

struct nodo *raiz=NULL;

void insertar(int x){
	struct nodo *nuevo;
	nuevo=malloc(sizeof(struct nodo));
	nuevo->info=x;
	nuevo->izq=NULL;
	nuevo->der=NULL;
	
	if(raiz==NULL){
		raiz=nuevo;
	} else {
		struct nodo *anterior, *reco;
		anterior=NULL;
		reco=raiz;
		
		while(reco!=NULL){
			anterior=reco;
			
			if(x<reco->info){
				reco=reco->izq;
			} else {
				reco=reco->der;
			}
		}
		
		if(x<anterior->info){
			anterior->izq=nuevo;
		} else {
			anterior->der=nuevo;
		}
	}
}

void imprimirPre(struct nodo *reco){
	if(reco!=NULL){
		printf("%i-", reco->info);
		imprimirPre(reco->izq);
		imprimirPre(reco->der);
	}
}

void imprimirEntre(struct nodo *reco){
	if(reco!=NULL){
		imprimirEntre(reco->izq);
		printf("%i-", reco->info);
		imprimirEntre(reco->der);
	}
}

void imprimirPost(struct nodo *reco){
	if(reco!=NULL){
		imprimirPost(reco->izq);
		imprimirPost(reco->der);
		printf("%i", reco->info);
	}
}

void borrar(struct nodo *reco){
	if(reco!=NULL){
		borrar(reco->izq);
		borrar(reco->der);
		free(reco);
	}
}

int main(){
	insertar(100);
	insertar(50);
	insertar(25);
	insertar(75);
	insertar(150);
	
	printf("Impresion preorden: ");
	
	imprimirPre(raiz);
	
	printf("\n\n");
	printf("Impresion entreorden: ");
	
	imprimirEntre(raiz);
	
	printf("\n\n");
	printf("Impresion postorden: ");
	
	imprimirPost(raiz);
	
	borrar(raiz);
	
	getch();
	return 0;
}

39.- TODOS LOS TIPOS DE DATOS PRIMIVTIVOS EN EL LENGUAJE C
Cada vez que necesitamos almacenar un entero utilizamos el tipo int, tambine dijimis que el tipo char permite almacenar un entero pequeno, pero el lenguaje C permite definir distintos tipos de enteros segun la capacidad maxima a almacenar y si necesitamos guardar el signo.

Hay cuatro modificadores detipo para las variables enteras: signed, unsigned, short y long que nos permiten ampliar los tipos enteros en el lenguaje C.

char (permite almacenar un valor entero entre -128 y 127 o entre 0 y 255 dependiendo del compilador utilizado).

signed char (permite almacenar un valor entero entre [-128, 127]).

unsigned char (permite almacenr un valor entero entre [0, 255]).

signed short int (permite almacenr un valor como minimi entre [-32767, 32767]).
Cuando definimos una variable de este tipo podemos resumitla poniendo solo short o short int o signed short.

unsigned int (permite almacenar un valot como minimo entre [-2147483648, 2147483647]).
Cuando definimos una variable de este tipo podemos resumirla poniendo solo int.
Recordemos que hasta ahora siempre utilizamos este tipo de dato para almacenar enteros, pero de ahora en mas podemos utilizar la mas eficiente segun la necesidd de almacenamiento.

unsigned int (permite almacenar un valor como minimo entre [0, 4294967295]).
Cuando definimos una variable de este tipo podemos resumirla poniendo solo unsigned.

signed long int (permite almacenar un valor como minimo entre [-2147483648, 2147483647]).
Cuando definimos una variable de este tipo podemos resumirla poniedo solo long o long int o signed long.

unsdigned long int (permite almacenar un valor como minimo entre [0, 4294967295]).
Cuando definimos una variable de este tipo podemos resumirla poneinfo solo unsigned long.

signed long long int (permite almacenar un valor como minimo entre [?9223372036854775807, 9223372036854775807])
Cuando definimos una variable de este tipo podemos reumirla poniendo solo long long o long long int o signed long long.

unsigned long long int (permite almacenar un valor comon minimo entre [0, 18446744073709551615]).
Cuando definimos una variable de este tipo podemos resumirla poniedo solo unsigned long long.

#include<stdio.h>
#include<conio.h>

int main()
{
	signed char c1=65;
	printf("ci es de tipo signed char:%c \n", c1);

	unsigned char c2=160;
	printf("c2 ed de tipo unsigned char:%c \n", c2);

	signed short int e1=3200;
	printg("e1 es dfe tipo short int:%i \n", e1);

	unsdigned short int e2=64000;
	printf("e2 es de tipo unsigned short int:%i \n", e2);

	signed int e3 =-2147483648;
	printf("e3 es de tipo signed int:%i \n", e3);

	unsigned int e4=4294967295;
	printf("e4 es de tipo unsigned int:%u \n", e4);

	signed long int e5=-2147483648;
	printf("e5 es de tipo signed long int:%li \n", e5);

	unsigned long int e6=2147483647;
	printf("e6 es de tipo unsigned long int:%lu \n", e6);

	signed long long int e7=-9223372036854775807;
	printf("e7 es de tipo signed long long int:%lli \n", e7);

	unsigned long long int e8=18446744073709551615;
	prinft("e8 es de tipo unsigned long long int:%llu \n", e8);

	getch();
	return 0;
}

Si queremos conocer cual es el valor maximo y minimo para cada uno de los tipos de datos enteros del lenguaje C podemos ejecutar el siguiente programa:

#include<stdio.h>
#include<conio.h>
#include<limits.h>

int main()
{
	printf("El minimo valor para un signed char = %i\n", SCHAR_MIN);
	printf("El maximo valor para un signed char = %i\n", SCHAR_MAX);
	printf("El maximo valor para un unsigned char = %i\n\n", UCHAR_MAX);

	printf("El minimo valor para un signed short int = %i\n", SHRT_MIN);
	printf("El maximo valor para un signed short int = %i\n", SHRT_MAX);
	printf("El maximo valor para un unsigned short int = %i\n\n", USHRT_MAX);

	printf("El minimo valor para un signed int = %i\n", INT_MIN);
	printf("El maximo valor para un signed int = %i\n", INT_MAX);
	printf("El maximo valor para un unsigned int = %u\n\n", UINT_MAX);

	printf("El minimo valor para un signed long int = %li\n", LONG_MIN);
	printf("El maximo valor para un signed long int = %li\n", LONG_MAX);
	printf("El maximo valor para un unsigned long int = %lu\n\n" ULONG_MAX);

	printf("El minimo valor para un signed long long int = %lli\n", LONG_LONG_MIN);
	printf("El maximo valor para un signed long long int = %lli\n", LONG_LONG_MAX);
	printf("El maximo valor para un unsigned long long int = %llu\n\n", ULONG_LONG_MAX);

	getch();

	return 0;
}

El archivo de invlusion limits.h tiene una serie de macros con los valores maximos y minimos definidos para nuestro compilador.

Debemos elegir la variable mas adecuada segun el valor maximo y minimo a guardar para que nuestro programa sea mas eficiente en cuanto a espacio para reservar como el tiempo de procesamiento de dichas variables.

Si queremos saber cuantos bytes se necesitan reservar para cada uno de los tipos de variables podemos ejecutar el programa:

#include<stdio.h>
#include<conio.h>

int main()
{
	printf("Bytes requeridos para tipo char: %i\n", sizeof(char));
	printf("Bytes requeridos para tipo short int: %i\n", sizeof(short int));
	printf("Bytes requeridos para tipo int: %i\n", sizeof(int));
	printf("Bytes requeridos para tipo long int: %i\n" sizeof(long int));
	printf("Bytes requeridos para tipo long long int: %i\n", sizeof(long long int));

	getch();

	return 0;
}

Como podemos ver definir una variable de tipo long long int require reservar 8 bytes para el almacenamiento del entero.

En el lenguaje C podemos definir variables decimales de tipo:

float
double
long double

Se diferencian en la precision como almacenan el valor real. La menos precisa es el tipo float, le sigue double y finalmente la mas precisa es long double.

#include<stdio.h>
#include<conio.h>

int main()
{
	printf("Bytes requeridos para tipo float: %i\n", sizeof(float));
	printf("Bytes requeridos para tipo double: %i\n", sizeof(double));
	printf("Bytes requeridos para tipo long double: %i\n", sizeof(long double));

	getch();

	return 0;
}

40.- OPERADOR DE MOLDE CON TIPOS ENTEROS Y REALIES (CAST)
Hemos visto que cuando realizamos una operacion con un conjunto de datos enteros el resultado es otro entero.

En algunas situaciones necesitamos que el resultado sea de otro tipo en estos casos utilizamos el concepto de cast (moldear):

float f = 7/2;
printf("%f, f); //3

Luego podemos ver si imprimimos la variable f su contenido es un 3.

Esto ocurre por que la division de un int con respecto a otro valor int da como resultado un entero.

Si queremos que el resultado sea exacto podemos anteceder entre parentesis al tipo de dato que queramos que se moldee:

float f = (float)7/2;
printf("%f", f); //3.5

#include<stdio.h>
#include<conio.h>

int main()
{
	int nota1, nota2, nota3;

	float promedio;

	printf("Ingrese primer nota: ");
	scanf("%i", &nota1);

	printf("Ingrese segunda nota: ");
	scanf("%i", &nota2);

	printf("Ingrese tercer nota: ");
	scanf("%i", &nota3);

	promedio = (float)(nota1+nota2+nota3)/3;

	printf("La nota promedio es: %0.2f", promedio);

	getch();

	return 0;

}

41.- OPERADORES DE ASIGNACION

Los operadores de asignacion mas comunes son:

+=
-=
*=
/=
%=

suma=suma+valor; --> suma+=valor;

42.- OPERADOR CONDICIONAL ?
Este operador hace mas compacta ciertas algoritmos en las que interviene una estructura condicional if.

int v1=1, v2=4, may = 0;

may = (v1>v2)?v1:v2;

printf("El valor mayor es: %i", may);

Hay que tener en cuenta que el operador conficional ?: puede remplazar el uso de if an algunas situaciones y no en todas.

La sintaxis del operadot condicinal entonces es:

condicion ? valor si cierto : valor si falso

Luego para usar el resultado que genera el operador condicional disponemos una sintaxis similar a esta:

variable = condicion ? valor si cierto : valor si falso

Ejemplo:
len += print_time(msg->ts_nsec, buf ? buf + len : NULL);

43.- ESTRUCTURA CONDICIONAL

#include<stdio.h>
#include<conio.h>

int main()
{
	int valor;

	printf("Ingrese un valor entre 1 y 5: ");
	scanf("%i", &valor);

	switch(valor){
		case 1:
			printf("Uno");
			break;
		case 2:
			printf("Dos");
			break;
		case 3:
			printf("Tres");
			break;
		default:
			printf("El valor esta fuera de rango.");
	}
}

char operacion;

printf("Ingrese la operacion quiere hacer: +, -, *, /: ");
scanf(" %c", &operacion);

switch (operacion){
	case '+':
		printf("La suma es: ");
		break;
	case '-':
		printf("La resta es: ");
		break;
	case '*':
		printf("El producto es: ");
		break;
	case '/':
		printf("La division es: ");
		break;
}

char palabra[50];
int f;

for(f=0; f<strlen(palabra); f++)
{
	switch (palabra[f]){
		case 'a':
		case 'e':
		case 'i':
		case 'o':
		case 'u':
			vocales++;
			break;
		default:
			consonantes++;
	}
}

44.- COMANDOS BREAK Y CONTNUE DENTRO DE ESTRUCTURAS REPETITIVAS
Hay dos comandos en el lenguaje C que modifican un ciclo repetitivo for, while o do while.

break
El primer comando se llama break y lo que hace es finalizar el ciclo repetitivo inmediatamente sin tener que analizar la condicion del ciclo.

for(int f=0; f<10; f++)
{
	printf("Ingrese un valor: ");
	scanf("%i", &valor);

	if(valor==0)
	{
		break;
	}
}


continue
El comando continue cuando se ejecuta vuelve al principio del ciclo repetitivo.

for(int f=0; f<5; f++)
{
	printf("Ingrese un valor: ");
	scanf("%i", &valor);

	if (valor>5 || valor<=0)
	{
		continue;
	}

	switch (valor){
		case 1: 
			printf("Uno");
			break;
		case 2:
			printf("Dos");
			break;
	}

	printf("\n");
}

En este problema cuando el if se verifica verdadero, es decir vuando el operador carga un valor mayor a  5 o menor o igual a cero se ejecuta el comando continue, en dicho caso la siguiente instuccion a ejecutarse es el incremento del contador f en la parte superior del for. Luego verifica la condicion y de ser verdadera se repite nuevamente el bloque del for.

Tengamos en cuenta que los break contenidos en el switch el lenguaje C no los confunde con comandos break contenidos en el for.

while(1)
{
	printf("Ingrese un valor (0 para finalizar): ");
	scanf("%i", &valor);

	if(valor==0)
	{
		break;
	}
	
	suma+=valor;
}

45.- COMANDO GOTO
Otro comando que tiene el lenguaje C es el goto. Este comando nos permite saltar en forma incondicional a cualquier otra parte de la misma funcion.

La sentencia goto no es aconsejada en la metodologia de programacion estructurada pero su uso en casos especiales nos permite crear codigo mas conciso.

Un caso comun donde se la utiliza es cunado queremos salir de una serie de for anidados a un bloque de la misma funcion pero fuera de dichos for (tener en cuenta que el comando break solo sale delfor que la contiene).

void cargar (int mat[FILAS][COLUMNA])
{
	int f, c;

	for(f=0; f<FILAS; f++)
	{
		for(c=0; c<COLUMNAS; c++)
		{
			printf("Ingrese elemento [%i, %i]: ", f, c);
			scanf("%i", &mat[f][c]);

			if(mat[f][c]==0)
			{
				goto salir;
			}
		}
	}

	return;

	salir: printf("Con un cero se termina la carga de elementos\n");
}

46.- FUNCION EXIT PARA TERMINAR UN PROGRAMA Y SYSTEM PARA LLAMAR OTRO
Funcion exit
La funcion exit interrumpe la ejecucion del programa en forma inmediata y retorna un entero al proceso que llamo el programa (normalmente este valor devuelto lo recibe el sistema operativo).

La sintaxis de esta funcion es:

void exit(int codigo)

Para poder llamar a esta funcion debemos importar el archivo de inclusion:

#include<stdlib.h>

El valor devuelto por convencion es un cero si el programa finaliza en forma correcta o un valor distinto a cero indicando distintos codigos de error que los puede interpretar quien ejecuto el programa.

Es importante notar que a exit la podemos llamar en cualquier parte de nuestro programa e inmediatamente el programa se detendara y no ejecutara mas comandos del mismo.

#include<stdio.h>
#include<conio.h>
#include<string.h>
#include<stdlib.h>

void ingresoClave()
{
	char clave[50];
	int intentos=0;

	do{
		if(intentos==3)
		{
			exit(1);
		}

		printf("Ingrese clave: ");
		gets(clave);
		intentos++;
	}	while (strcmp(clave, "123abc")!=0);
}

int main()
{
	ingresoClave();

	printf("Bienvenido\n");
	
	getch();

	return 0;
}

Funcion system
La funcion system nos permite ejecutar otro programa. Debemos pasr como parametro una cadena con el nombre del programa a ejecutar, debe ser un programa ejecutable el mismo.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	int codigo;

	codigo=system("program199.exe");

	printf("El programa finalizo retornando el codigo: %i", codigo);

	getch();

	return 0;
}

Si indicamos el path el codigo quedaria:
codigo=system("c:\\programasc\\programa199.exe");

47.- DEFINICION DE CONSTANTES (CONST)
Si necesitamos almacenar un valor en una variable que nunca seta cambiado el lenguaje C nos permite definir una constante.

const int impuesto=21;

La definicion como constante del indentificador impuesto asegura que cualquier intento de asignarle otro valor generara un error cuando compilemos el programa:

impuesto=25; //error

Se pueden definir constantes de cualquier tipo de dato que nos provee el lenguaje C.

Una constante a diferencia de una macro ocupa un espacio durante la ejecucion del programa:

#define PI 3.1416

const float pi=3.1416;

Es importante notar que pi reserva espacio para un valor float durante la ejecucion del programa, en cambio la macro PI cuando compilamos se sustituye todas las partes que aparece PI por el valor 3.1416.

#include<stdio.h>
#include<conio.h>

struct persona {
	char nombre[50];
	int edad;
};

int main()
{
	const short int v1=30000;
	const int v2=2000000;
	const float r1=10.55;
	const char l1='A';
	const struct persona per1={"juan", 18};

	getch();

	return 0;
}

Modificador const en los parametros de una funcion
Cuando un parametro no debe ser modificado es conveniente agregarle el modificador const para evitar que por descuido le asignemos un valor.

void impirmir(const int vec[3])
{
	int f;

	for(f=0; f<3; f++)
	{
		printf("%i", vec[f]);
	}
}

48.- EMPLEO DE LLAVES OPCIONALES EN ESTRUCTURAS CONDICIONALES Y REPETITIVAS
Las llaves de apertura y cerrado de una estructura condicional y repetitiva en el lenguaje C es opcional si hay una sola instruccion.

int v1, v2;

if (v1>v2)
	printf("El valor mayor es %i", v1);
else
	printf("El valor mayor es %i", v2);

int x;
for(x=1; x<=10; x++)
	printf("%i\n", x);

49.- DECLARACION DE ENUMERACIONES
Una enumeracion es un tipo de dato que creamos asociando un conjunto de enteros con un conjunto de literales.

enum operaciones {SUMA, RESTA, MULTIPLICACION, DIVISION};
enum respuesta {NO, SI};
enum boolean {FALSE, TRUE};

Como vemos la declaracion de un tipo de dato enumerado se declara mediante la palabra clave enum y seguidamente el nombre del tipo de datos, luego entre llaves indicamos todas los valores que puede almacenar una variable de ese tipo. La primer constante o literal indicado toma el valor cero, la segunda el valor 1 y asi sucesivamente.

Podemos declarar la enumeracion con la sintaxis:

enum operaciones {SUMA=0, RESTA=1, MULTIPLICACION=2, DIVISION=3};

Pero es opcional si queremos iniciar a partir de cero la enumeracion el propio compilador lo hace.

Luego para definir una variable de tipo enumeracion utilizamos la sintaxis:

enum operaciones op;

Definimos la variable op de tipo operaciones. Luego en la variable op podemos almacenar cualquiera de los cuatro literales definidos en la enumeracion:

op=MULTIPLICACION;

Las enumeracions tienen por objetivo que el programa sea mas legible para cuando tengamos que hacer cambios. Si no existieran las enumeraciones podemos definir una variable entera y recordar que el 0=SUMA, 1=RESTA, 2=MULTIPLICACION y 3=DIVISION.

int op; //si guardo 0=suma, 1=resta, 2=multiplicacion y 3=division
op=2;

#include<stdio.h>

enum texiste {NO, SI};

void consulta(int vec[3])
{
	enum texiste existe = NO;

	for(int f=0; f<3; f++)
		if(valor==vec[f])
			existe=SI;
	
	if(existe==SI)
		printf("El valor ingresado esta dentro del vector");
	else
		printf("El valor ingresado no esta dentro del vector");
}

#include<stdio.h>
#include<stdlib.h>

enum operacion {SUMAR, RESTAR, MULTIPLICAR, DIVIDIR};

int operar(int v1, int v2, enum operacion op)
{
	switch(op){
		case SUMAR: return v1+v2;
		case RESTAR: return v1-v2;
		case MULTIPLICAR: return v1*v2;
		case DIVIDIR: return v1/v2;
		default: printf("El programa se detien por operacion no valida.");
				exit(1);
	}
}

Asignacion de otros valores a los literales

Podemos iniciar los literales a partir de otro valor y no de cero:

enum diassemana {LUNES=1, MARTES, MIERCOLES};

Podemos asignar valores no consecutivos a cada uno:

enum dispositivos {TECLADO=1, MOUSE=10, CAMARA=100};

50.- DECLARACION DE UNIONES
La union es una estructura de datos muy particular del lenguaje C. La declaracion de una union es similar a un registro (struct).

union dato{
	int x;
	char letra;
	char cadena[5];
};

Como vemos cambiamos la palabra clave struct por union, hasta ahi la semejanza con los registros.

Cuando definimos una variable de un tipo  union utilizamos la sintaxis:

union dato d;

La caracteristica fundamental es que se reserva el mismo espacio de memoria para lso atriburos x, letra y cadena[5].

En una variable de tipo stuct cada campo reserva un espacio distinto de memoria en cambio en una union todas comparten el mismo espacio. Se reservapara el tipo de dato mayor contenida en al union, si tenemos que x es un int y ocupa 4 bytes, letra es un tipo char y ocupa 1 byte y el vector cadena ocupa 5 bytes luego significa que cuando defino la variable d de tipo union dato se estara reservando 5 bytes de memoria.

51.- DEFINICION DE NUEVOS NOMBRES PARA TIPOS DE DATOS EXISTENTES (TYPEDEF)
En el lenguaje C existen muchos tipos de datos primitivos (int, char, float, etc.) y estructuras de datos.

Mediante la palabra clave typedef podemos definir un alias para un tipo de dato existente:

#include<stdio.h>
#include<conio.h>

typedef int entero;

int main()
{
	entero edad1, edad2;

	edad1=5;
	edad2=7;

	printf("Las edades son: %i y %i", edad1, edad2);

	getch();

	return 0;
}

Decimos que el nombre "entero" es un alias del tipo de dato int.

La declaracion de tipos tiene por objetivo hacer que nuetro programa sea mas legible.

typedef con struct
Podemos declarar un alias para un tipo de dato registro.

typedef struct {
	int codigo;
	char descripcion[41];
	float precio;
} tproducto;

int main()
{
	tproducto pro1, pro2;
}

------------------------------

struct producto {
	int codigo;
	char descripcion[41];
	float precio;
};

typedef struct producto tproducto;

int main()
{
	tproducto pro1, pro2;
}


typedef con struct y array

Podemos declarar un alias para un tipo de dato de array de registros.

#define TAM 5

struct persona {
	char nombre[40];
	int edad;
};

typedef struct persona tpersonas[TAM];

int main()
{
	tpersonas personas;
}

--------------------------------

struct nodo{
	int info;
	struct nodo *sig;
};

typedef struct nodo * tnodo;

tnodo raiz=NULL;

52.- VARIABLES LOCALES STATIC
Hemos visto que cuando definimos una variable loval su valor se pierde inmediatamente cuando finaliza la funcion.

En el lenguaje C podemos definir variables locales que no pierdan su valor entre llamadas mediante el modificador static.

Veamos con dos programas la diferencia entre definir una variable local y una variable local static:

void imprimir()
{
	int x=0;
	x++;
	printf("%i", x);
}

int main()
{
	imprimir();
	imprimir();
	imprimir();

	getch();

	return 0;
}

//111

Cada vez que se llama a la funcion imprimir se define una variable local llamada x, se la inicializa con 0 y luego se la incrementa en uno y se imprime su valor.

Si queremos que la variable x no pierda su valor entre llamadas a la funcion imprimir se le antecede el modificador static:

void imprimir()
{
	static int x=0;
	x++;
	printf("%i", x);
}

int main()
{
	imprimir();
	imprimir();
	imprimir();

	getch();

	return 0;
}

//123

53.- APLICACION EN C CON MAS DE UN ARCHIVO FUENTE (PROYECTOS CON MULTIPLES ARCHIVOS)
Crear una carpeta proyecto001.
Entrar en la carpeta.
Crear una carpeta Sources.
Crear una carpeta Headers
En la carperta Sources agregar archivos:
main.c
productos.c
En la carpeta Headers agregar archivo:
productos.h
Editar codigo correspondiente:

productos.h

typedef struct{
	int codigo;
	char descripcion[41];
	float precio;
} tproducto;

#define CANT 4

void cargar(tproducto productos[CANT]);
void imprimir(tproducto productos[CANT]);

main.c

#include<stdio.h>
#include"produntos.h"

int main()
{
	tproducto productos[CANT];
	int opcion;

	do{
		printf("1.- Carga de productos.\n");
		printf("2.- Listado de productos.\n");
		printf("3.- Finalizar programa..\n\n");
		printf("Elija su opcion: ");
		scanf("%i", &opcion);

		switch(opcion){
			case 1:cargar(productos);
					break;
			case 2:imprimir(productos);
					break;
		}
	} while(opcion!=3);

	return 0;
}

productos.c

#include<stdio.h>
#include"productos.h"

void cargar(tproducto productos[CANT])
{
	int f;

	for(f=0; f<CANT; f++)
	{
		printf("Ingrese el codigo: ");
		scanf("%i", &productos[f].codigo);

		fflush(stdin);

		printf("Ingrese la descripcion: ");
		gets(productos[f].descripcion);

		printf("Ingrese el precio: ");
		scanf("%f", &productos[f].precio);
	}
}

void imprimir(tproducto productos[CANT])
{
	int f;

	for(f=0; f<CANT; f++)
	{
		printf("Codigo: %i\n", productos[f].codigo);
		printf("Descripcion: %s\n", productos[f].descripcion);
		printf("Precio:%0.2f\n", productos[f].precio);
	}

	printf("\n\n");
}

54.- DEFINICION DE FUNCIONES Y VARIABLES STATIC
Cuando tenemos proyectos grandes cada uno de los archivos *.c tienen como objetivo definido y lo llevan a cabo implementando funciones.

Las funciones que implementa un archivo *.c son accedidas desde otros archivos.

Cuando queremos implementar funciones que solo puedan ser llamadas desde fucniones del mismo archivo debemos anteceder el modificador static previo al nombre de la funcion.

Una funcion static se oculta al resto de archivos del proyecto, con esto logramos encapsular funcionalidades dentro de un archivo.

El modificador static aplicada a una variable global definida en el archivo tambien solo puede ser accedida por las funciones de ese archivo.

#include<stdio.h>
#include"productos.h"

static void mostrarTitulo(char *tit)
{
	printf("%s\n", tit);
}

static void mostrarAsteriscos()
{
	printf("******************************************************************\n\n");
}

void cargar(tproducto productos[CANT])
{
	int f;
	
	mostrarTitulo("Cargar de datos de productos");

	for(f=0; f<CANT; f++)
	{
		//...
	}

	mostrarAsteriscos();
}

55.- VARIABLES GLOBALES CON EL MODIFICADOR EXTERN
Cuando tenemos una aplicacion constituida por varios archivos *.c y queremos acceder a una variable global de un archivo en otro archivo debemos declarar la variable global con el modificador extern.

Cuando una variable global se declara como extern, el compilador no crea un espacio para ella en memoria, sino que, tan solo tiene en cuenta que dicha variable ya ha sido declarada en otro archivo del programa.

pila.h

struct nodo{
	int info;
	struct nodo *sig;
};

typedef struct nodo * tnodo;

void insertar(int x);
void imprimir();
int extraer();
void liberar();

main.c

#include<stdio.h>
#include<conio.h>
#include"pila.h"

tnodo raiz=NULL;

int main()
{
	insertar(10);
	insertar(40);
	insertar(3);

	imprimir();

	printf("Extraemos de la pila: %i\n", extraer());

	imprimir();
	liberar();

	getch();

	return 0;
}

pila.c

#include<stdio.h>
#include<stdlib.h>
#include"pila.h"

extern tnodo raiz;

void insertar(int x)
{
	tnodo nuevo;
	nuevo = malloc(sizeof(struct nodo));
	nuevo->info = x;

	if(raiz == NULL)
	{
		raiz = nuevo;
		nuevo->sig = NULL;
	}
	else
	{
		nuevo->sig = raiz;
		raiz = nuevo;
	}
}

void imprimir()
{
	tnodo reco=raiz;
	printf("Lista completa.\n");

	while(reco!=NULL)
	{
		printf("%i", reco->info);
		reco=reco->sig;
	}

	printf("\n");
}

56.- MODIFICADOR INLINE EN LA DEFINICION DE FUNCIONES
Otra herramienta mas en busca de hacer que nuestro programa sea lo mas eficinete es permitirnos endicar al compilador que una funcion se inserte su codigo en lugar de ser llamada.

Para indicar al compilador que inserte el algoritmo de la funcion se utiliza la palabra clave inline previo a la definicion de la misma.

El modificador inline se hace fundamental en funciones que realizan algoritmos muy cortos.

#include<stdio.h>
#include<conio.h>

static inline int calclarCuadrado(int x)
{
	return x*x;
}

int main(){
	printf("El cuadrado de5 es: %i", calcularCuadrado(5));
	getch();
	return 0;
}

Con el modificador inline en la definicion calcularCuadrado estamos solicitando al compilador que en lugar de llamar a la funcion sustituya el algoritmo de la misma, como si nosotros hubieramos codificado:

printf("Elcuadrado de 5 es: %i", 5*5);

57.- ARCHIVOS BINARIOS: CREACION Y GRABACION DE TIPO DE DATOS PRIMITIVOS (FOPEN, FWRITE, FCLOSE)
Hemos aprnedido distintas estructuras de datos que nos permiten administrar informacion en la memoria RAM de nuestra computadora.

Ahora veremos otra estructura de datos que nos permite almacenar datos en una memoria secuadaria de nuestra computadora como podria ser el disco duro, pendrive, etc.

Esta estructura de datos son los archivos. Un archivo veremos que es independiente a nuestro programa y podra ser accedido luefo por otros programas.

Un archivo podemos imaginarlo en forma similar a un vector. Tambien a un archivo los distintos componentes (bytes) se ubican uno a continuacion del otro, y al igual que en los vectores, los componentes de un archivo en C tambien son automaticamente numerados con indices, desde el 0 (cero) en adelante. Pero la forma de procesar un archivo difiere totalmente con respecto a un vector.

Podemos clasificar los archivos segun el formato como se guardan los datos en:

-Archivos binarios.
-Archivos de texto.

Crear un archivo binario y almacenar un caracter, un entero y un flotante. Identificar en el disco duro el archivo creado y cual es su tamano en bytes.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	FILE *arch;

	arch=fopen("archivo1.dat", "wb");

	if (arch==NULL)
		exit(1);
	
	char letra='A';

	fwrite(&letra, sizeof(char), 1, arch);

	int valor1=12;

	fwrite(&valor1, sizeof(int), 1, arch);

	float valor2=5.25;

	fwrite(&valor2, sizeof(float), 1, arch);

	fclose(arch);

	printf("Se creo un archivo binario que almacena un char, un int y un float.");

	getch();
	return 0;
}

fopen

El primer parametro indicamos el nombre del archivo a crear, debe ser un nombre valido para el sistema operativo donde se ejecuta. Con wb estamos pidiendo a fopen que cree el archivo binario (si ya existe se borra el actual y se crea uno nuevo vacio).

La funcion fwrite tiene 4 parametros:

-Al primer parametro hay que pasar la direccion de la variable a grabar en el archivo.
-Al segundo parametro hay que pasar la cantidad de bytes de tipo de datos a grabar. Normalmente utilizamos el operador sizeof para recuperar el tamano.
-El tercer parametro le pasamos un 1 ya que guardamos solo una variable (tendra snetido cuando grabemos todo un vector con una sola llamada).
-El cuarto parametro es el nombre logico del archivo.

58.- ARCHIVOS BINARIOS: LECTURA DE DATOS PRIMITIVOS (FREAD)
Vimos en el concepto anterior como crear archivos binarios y grabar tipos de datos primitivos empleando las funciones que provee el lenguaje C.

Ahora veremos como leer los datos contenidos en un archivo binario.

Para trabajar con los datos almacenados en un archivo debemos hacer uan copia de los msimos en la memoria RAM.

Debemos conocer los tipos de datos almacenados enel archivo binario y el orden exacto como estan guardados.

Abrir el archivo binario que se creo en el concepto anterior "archivo1.dat y leer sus datos. Recordemos que el archivo almacena un caracter, un entero y un floar en ese orden.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	FILE *arch;

	arch=fopen("archivo1.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	char c;
	fread(&c, sizeof(char), 1, arch);
	printf("Caracter: %c\n", c);

	int v1;
	fread(&v1, sizeof(int), 1, arch);
	printf("Entero: %i\n", v1);

	float v2;
	fread(&v2, sizeof(float), 1, arch);
	printf("Float: %0.2f\n", v2);

	fclose(arch);

	getch();
	return 0;

}

Si no conocemos la estructura interna del archivo binario (en nuestro ejemplo un char, un int y finalmente un float) sera imposible recuperar correctamente la informacion almacenada.

59.- ARCHIVOS BINARIOS: DESPLAZAMIENTO DEL PUNTERO DE ARCHIVO (FSEEK)
Veremos ahora una funcion que nos permite desplazar el puntero de archivo a cualquier posicion previo a la lectura.

Con el desplazamiento del puntero de archivo no estamos obligados a leer en forma secuencial los datos.

La funcion qeu nos permite desplazar el puntero de archivo se llama fseek y tiene tres parametros:

fseek([nombre logico del archivo], [cantidad de bytes a desplazarse], [ubicacion desde donde comenzar a desplazarse])

El tercer parametro puede tomar alguno de estos tres valores (son tres macros definidas en el archivo stdio.h):

-SEEK_SET: Reposicionar comenzando desde el principio del archivo (es lo mismo poner un 0).
-SEEK_CUR: Reposicionar comenzando desde la posicion actual del puntero (es lo mismo poner un 1).
-SEEK_END: Reposicionar comenzando desde el final del archivo (es lo mismo poner un 2).

Abrir el archivo binario que se creo en conceptos anteriores: archivo1.dat y leer solo los bytes donde se alamcena el valor float. Recordemos que el archivo almacena un caracter, un entero y un float en ese orden.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	FILE *arch;

	arch=fopen("archivo1.dat", "rb");

	if (arch==NULL)
		exit(1);
	
	float v2;
	
	fseek(arch, 5, SEEK_SET);
	fread(&v2, sizeof(float), 1, arch);

	printf("Float: %0.2f\n", v2);

	fclose(arch);
	
	getch();
	return 0;
}

Abrir el archivo binario "archivo1.dat" y leer e imprimir el char y el float.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	FILE *arch;

	arch=fopen("archivo1.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	char c;
	fread(&c, sizeof(float), 1, arch);
	printf("Caracter: %c\n", c);

	float v2;
	fread(&v2, sizeof(float), 1, arch);
	printf("Float: %0.2f\n", v2);

	fclose(arch);

	getch();
	return 0;
}

El puntero avanza un byte luego de leer, entonces como queremos leer el float que se encuentra despues del int procedemos a avanzar desde la posicion actual (SEEK_CUR) cuatro bytes.

60.- ARCHIVO BINARIOS: AGREGAR DATOS
Hemos visto que cuando necesitamos crear un archivo lo hacemos pasando a la funcion fopen el valor "wb". Con esto indicamos que se cree el archivo y si ya existe lo borre y lo cree nuevamente vacio.

En muchas situaciones podemos necesitar agregar datos al archivo sin tenerlo qeu borrar, para esto debemos pasar a la funcion fopen el valor ab (append binary).

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void crear()
{
	FILE *arch;

	arch=fopen("archivo3.dat", "wb");

	if(arch==NULL)
		exit(1);
	
	int valor1=10;
	fwrite(&valor1, sizeof(int), 1, arch);

	int valor2=20;
	fwrite(&valor2, sizeof(int), 1, arch);

	int valor3=30;
	fwrite(&valor3, sizeof(int), 1, arch);

	fclose(arch);
}

void agregar()
{
	FILE *arch;
	
	arch=fopen("archivo3.dat", "ab");

	if(arch==NULL)
		exit(1);

	float f1=5.45;
	fwrite(&f1, sizeof(float), 1, arch);

	fclose(arch);
}

void imprimir()
{
	FILE *arch;

	arch=fopen("archivo3.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	int v1, v2, v3;

	fread(&v1, sizeof(int), 1, arch);
	printf("Entero: &i\n", v1);

	fread(&v2, sizeof(int), 1, arch);
	printf("Entero: &i\n", v2);

	fread(&v3, sizeof(int), 1, arch);
	printf("Entero: &i\n", v3);

	float f1;
	fread(&f1, sizeof(float), 1, arch);
	printf("Float: %0.2f\n", f1);

	fclose(arch);
}

int main()
{
	crear();
	agregar();
	imprimir();

	getch();
	return 0;
}

61.- ARCHIVOS BINARIOS: MODIFICAR DATOS
Hemos visto hasta ahora como se crea un archivo binario desde C, como se lo lee, como se agregan datos al final. Nos esta quedando como modificar datos almacenados en el archivo.

Listado completo de modos de apertura de archivos binarios:

rb.- Solo lectura. El archivo debe existir previamente. si no existe, fopen retorna NULL.
wb.- Solo escritura. Si el archivo no existia, lo crea. Si existia, destruye su contenido y lo abre vacio.
ab.- Solo escritura, pero en modo append (o sea anadir): Los datos que se graban, lo hacen al final. Crea el archivo si no existia, y no destruye su contenido si ya existia.
r+b.- Permite lectura y escritura. El archivo debe existir previamente.
w+b.- Permite escritura y lectura. Crea el archivo si no existia, pero destruye su contenido si ya existia, y lo abre vacio.
a+b.- Permite anadir al final, en modo lectura-escritura. Crea el archivo si no existia. No destruye su contenido si ya existia.

Confeccionar un programa con tres funciones:
1.- Creacion de un archivo binario llamado "archivo4.dat" y almacenar 3 enteros. Seguidamente cerrar el archivo.
2.- Abrir nuevamente el archivo pero en modo "r+b" y modificar el segundo entero almacenado en el archivo.
3.- Finalmente abrir el archivo para lectura y mostrar todos sus datos.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void crear()
{
	FILE *arch;

	arch=fopen("archivo3.dat", "wb");

	if(arch==NULL)
		exit(1);
	
	int valor1=10;
	fwrite(&valor1, sizeof(int), 1, arch);

	int valor2=20;
	fwrite(&valor2, sizeof(int), 1, arch);

	int valor3=30;
	fwrite(&valor3, sizeof(int), 1, arch);

	fclose(arch);
}

void modificar()
{
	FILE *arch;
	
	arch=fopen("archivo3.dat", "r+b");

	if(arch==NULL)
		exit(1);
	
	fseek(arch, 4, SEEK_SET)

	int x=100;
	fwrite(&x, sizeof(int), 1, arch);

	fclose(arch);
}

void imprimir()
{
	FILE *arch;

	arch=fopen("archivo3.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	int v1, v2, v3;

	fread(&v1, sizeof(int), 1, arch);
	printf("Entero: &i\n", v1);

	fread(&v2, sizeof(int), 1, arch);
	printf("Entero: &i\n", v2);

	fread(&v3, sizeof(int), 1, arch);
	printf("Entero: &i\n", v3);

	fclose(arch);
}

int main()
{
	crear();
	modificar();
	imprimir();

	getch();
	return 0;
}

62.- ARCHIVOS BINARIOS: IDENTIFICAR FINAL DE ARCHIVO (FEOF)
Hemos visto la funcion fread que nos permite recuperar dtos de un archivo binario. Ahora veremos otra funcion disponible en stdio.h que nos permite luego de la ejecucion de la funcion fread verificar si se ha llegado a fin de archivo:

int feof([nombre logico del archivo]);

Esta funcion devuelve 0 si no es fin de archivo y un valor distinto a 0 si se ha llegado al final de archivo.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void crearCargar()
{
	FILE *arch;

	arch=fopen("archivo4.dat", "wb");

	if(arch==NULL)
		exit(1);
	
	int valor;

	do{
		printf("Ingrese valor entero (0 para finalizar): ");
		scanf("%i", &valor);

		if(valor!=0)
			fwrite(&valor, sizeof(int), 1, arch);
	} while(valor!=0);

	fclose(arch);
}

void imprimir()
{
	FILE *arch;

	arch=fopen("archivo4.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	printf("Todos los dtos almacenados en el archivo.\n");

	int x;

	fread(&x, sizeof(int), 1, arch);

	while(!feof(arch))
	{
		printf("%i", x);
		fread(&x, sizeof(int), 1, arch);
	}

	fclose(arch);
}

int main()
{
	crearCargar();
	imprimir();

	getch();
	return 0;
}

63.- ARCHIVOS BINARIOS: POSICION ACTUAL DEL PUNTERO DE ARCHIVO (FTELL)
Medienate la funcion fseek podemos desplazar el puntero de archivo a cualquier byte del mismo, como vimos si queremos grabar datos al final lo desplazamos con el fseek facilmente al final.

Ahora veremos que hay una funcion que nos informa en que byte del archivo esta el puntero:

int ftell([nombre logico del archivo]);

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void crear()
{
	FILE *arch;

	arch=fopen("archivo6.dat", "wb");

	if(arch==NULL)
		exit(1);
	
	int valor1=10;
	fwrite(&valor1, sizeof(int), 1, arch);
	int pos=ftell(arch);
	printf("Posicion del puntero de archivo luego grabar un esntero:%i\n", pos);

	int valor2=20;
	fwrite(&valor2, sizeof(int), 1, arch);
	pos=ftell(arch);
	printf("Posicion del puntero de archivo luego grabar un entero:%i\n", pos);

	int valor3=30;
	fwrite(&valor3, sizeof(int), 1, arch);
	pos=ftell(arch);
	printf("Posicion del puntero de archivo luego grabar un entero:%i\n", pos);

	fclose(arch);
}

void imprimir()
{
	FILE *arch;

	arch=fopen("archivo6.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	printf("Todos los datos almacenados en el archivo.\n");

	int x;
	int pos;

	fread(&x, sizeof(int), 1, arch);

	while(!feof(arch))
	{
		pos=ftell(arch);
		printf("dado leido %i y posicion del puntero de archivo %\n", x, pos);
		fread(&x, sizeof(int), 1, arch);
	}

	fclose(arch);
}

int main()
{
	crear();
	imprimir();

	getch();

	return 0;
}

Confeccionar un programa que imprima el tamano en bytes del archivo "archivo6.dat" creado en el programa anterior.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

int main()
{
	FILE *arch;

	arch=fopen("archivo6.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	fseek(arch, 0, SEEK_END);

	int pos=ftell(arch);

	printf("El tamano del archivo \"archivo6.dat\" es de %i bytes", pos);

	fclose(arch);

	getch();
	
	return 0;
}

64.- ARCHIVOS BINARIOS: GRABAR Y LEER VECTORES COMPLETOS EN UN ARCHIVO
Veremos ahora como cuando necesitamos grabar o leer un vector en una sola llamada a la funcion fread o fwrite indicamos en dicho tercer parametro el tamano del vector.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

#define TAM 10

void grabarVector()
{
	FILE *arch;

	arch=fopen("archivo7.dat", "wb");

	if(arch==NULL)
		exit(1);
	
	int vec[TAM]={10, 20, 30, 40, 50, 60, 70, 80, 90, 100};

	fwrite(vec, sizeof(int), TAM, arch);

	fclose(arch);
}

void recuperarVector()
{
	FILE *arch;

	arch=fopen("archivo7.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	int vec[TAM];

	fread(vec, sizeof(int), TAM, arch);

	int f;

	for(f=0; f<TAM; f++)
	{
		printf("%i", vec[f]);
	}

	fclose(arch);
}

int main()
{
	grabarVector();
	recuperarVector();

	getch();

	return 0;
}

Es importante hacer notar que no le disponemos el caracter & previo al nombre vec debido a que los vectores son punteros en el lenguaje C y por lo tanto estamos enviando la direccion del vector al enviarle vec.

Ahora en el tercer parametro indicamos la macro TAM que sera remplazada por el valor 10 (esto debido a que el vector tiene 10 enteros).

La funcion para recuperar los 10 int almacenados en el archivo tambien los hacemos con una sola llamada a la funcion fread.

65.- ARCHIVO BINARIOS: AGREGAR, CONSULTAR Y MDOIFICAR RESGISTROS (STRUCT) EN UN ARCHIVO

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

typedef struct{
	int codigo;
	char descripcion[41];
	float precio;
} tproducto;

void continuar()
{
	printf("Presione una tecla para continuar\n\n");
	getch();
}

void crear()
{
	FILE *arch;
	arch=fopen("productos.dat", "wb");

	if(arch==NULL)
		exit(1);

	fclose(arch);
		
	continuar();
}

void cargar()
{
	FILE *arch;
	
	arch=fopen("productos.dat", "ab");

	if(arch==HULL)
		exit(1);
	
	tprodcuto producto;

	printf("Ingrese el codifo del producto: ");
	scanf("%i", &producto.codigo);

	fflush(stdin);

	printf("Ingrese el nombre del producto: ");
	gets(producto.descripcion);

	printf("Ingrese precio: ");
	scanf("%f", &producto.precio);

	fwrite(&producto, sizeof(tproducto), 1, arch);

	fclose(arch);

	continuar();
}

void listado()
{
	FILE *arch;

	arch=fopen("productos.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	tproducto producto;

	fread(&producto, sizeof(tproducto), 1, arch);

	while(!feof(arch))
	{
		pirntf("%i %s %0.2f\n", producto.codigo, producto.descripcion, producto.precio);
		fread(&producto, sizeof(tproducto), 1, arch);
	}

	fclose(arch);
	continuar();
}

void consulta()
{
	FILE *arch;

	arch=fopen("productos.dat", "rb");

	if(arch==NULL)
		exit(1);
	
	printf("Ingrese el codigo de producto a consultar: ");

	int cod;
	scanf("&i", &cod);

	tproducto producto;

	int existe=0;

	fread(&producto, sizeof(tproducto), 1, arch);

	while(!feof(arch))
	{
		if(cod==producto.codigo)
		{
			printf("%i %s %0.2f\n", producto.codigo, producto.descripcion, producto.precio);
			existe=1;
			break;
		}

		fread(&producto, sizeof(tproducto), 1, arch);
	}

	if(existe==0)
		printf("No existe un producto con dicho codigo\n");
	
	fclose(arch);
	continuar();
}

void modificacion()
{
	FILE *arch;

	arch=fopen("productos.dat", "r+b");

	if(arch==NULL)
		exit(1);
	
	printf("Ingrese el codifo de producto a modificar: ");

	int cod;

	scanf("%i", &cod);

	tproducto producto;

	int existe=0;

	fread(&producto, sizeof(tproducto), 1, arch);

	while(!feof(arch))
	{
		if(cod==producto.codigo)
		{
			printf("%i %s %0.2f\n", producto.codigo, producto.descripcion, producto.precio);
			
			printf("Ingrese nuevo precio: ");
			SCANF("&f", &producto.precio);

			int pos=ftell(arch)-sizeof(tproducto);

			fseek(arch, pos, SEEK_SET);

			fwrite(&producto, sizeof(tproducto), 1, arch);

			printf("Se modifico el precio para dicho produto.\n");

			existe=1;

			break;
		}

		fread(&producto, sizeof(tproducto), 1, arch);
	}

	if(existe==0)
		printf("No existe un producto con dicho codigo\n");
	
	fclose(arch);

	continuar();
}

int main()
{
	int opcion;

	do{
		printf("1.- Crear un archivo binario llamado \"productos.dat\"n");
		printf("2.- Carga de registros de tipo tproducto\n");
		printf("3.- Listado completo de productos.\n");
		printf("4.- Consulta de un producto por su codigo.\n");
		printf("5.- Modificacion del precio de un producto.\n");
		printf("6.- Finalizar\n\n");
		
		printf("Ingrese su opcion: ");
		scanf("%i", &opcion);

		switch(opcion){
			case 1: crear();
					break;
			case 2: cargar();
					break;
			case 3: listado();
					break;
			case 4: consulta();
					break;
			case 5: modificacion();
					break;
		}
	} while(opcion!=6);

	return 0;
}

66.- ARCHIVO DE TEXTO: CREACION Y GRABACION DE DATOS
Ahora veremos otro formato de archivos llamado "archivos de texto".

Una archivo de texto contiene solo caracteres legibles por el ser humano con la salveda del salto de linea que le serive a un editor de texto para comenzar a mostrar los siguientes caracteres una linea mas abajo.

Es un formato muy utilizado los podemos encontrar en archivos de configuracion, los archivos de cofigo fuente en C u otros lenguajes, las paginas HTML, archivos XML etc.

Un archivo de texto lo podemos editar (crear, agregar, modificar y borrar desde cualquier editor de texto).

El lenguaje C provee una serie de funciones para procesar en forma sencilla un archivo de texto.

Listado completo de modos de apertura de archivos de texto:

rt.- Solo lectura. El archivo debe existir previamente. Si no existe, fopen retorna NULL.
wt.- Solo exritura. Si el archivo no existia, lo crea. Si existia, destruye su contenido y lo abre vacio.
at.- Solo escritura, pero en modo append (o sea anadir): Los datos que se graban, lo hacen al final. Crea el archivo si no existia y no destruye su contenido si ya existia.
r+t.- Permite lectura y escritura. El archivo debe existir previamente.
w+t.- Permite escritura y lectura. Crea el archivo si no existia, pero destruye su contenido si ya existia, y lo abre vacio.
a+t.- Permite anadir al final, en modo lectura - escritura. Crea el archivo si no existia. No destruye su contenido si ya existia.

Crear un archivo de texto llamado datos1.txt y almacenar tres lineas. Acceder a su contenido luego con al menos dos editores de texto.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void main()
{
	FILE *arch=fopen("datos1.txt", "wt");

	if(arch==NULL)
		exit(1);
	
	fputs("Primer linea\n", arch);
	fputs("Segunfa linea\n", arch);
	fputs("Tercer linea\n", arch);

	fclose(arch);

	printf("Se creo el archivo de texto con tres lineas de texto.");

	getch();

	return 0;
}

67.- ARCHIVO DE TEXT: LECTURA
Vimos en el concepto anterior como crear y grabar datos en un archivo de texto. La visualizacion de su contenido la hicimos desde un editor de texto.

Ahora veremos como acceder al contenido del archivo desde nuestro programa.

Abrir el archivo datos1.txt en modo lectura, leer todas sus lineas y mostrar su contenido por pantalla.

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

void main()
{
	FILE *arch=fopen("datos1.txt", "rt");

	if(arch==NULL)
		exit(1);
	
	char caracter=fgetc(arch);

	while(!feof(arch))
	{
		printf("%c", caracter);
		caracter=fgetc(arch);
	}

	fclose(arch);

	getch();

	return 0;
}

Ahora con fgets

#include<stdio.h>

void main()
{
	FILE *arch=fopen("datos1.txt", "rt");

	if(arch==NULL)
		exit(1);
	
	char linea[100];

	fgets(linea, 100, arch);

	while(!feof(arch))
	{
		printf("%s", linea);
		fgets(linea, 100, arch);
	}

	fclose(arch);

	getch();

	return 0;
}

La funcion fgets leer cadenas de caracteres tantos como los indicados en el segundo parametro menos 1, o hasta que lea un salto de linea \n o se llegue al final de archivo.

Dentro de la variable linea tambien se almacena el salto de linea \n.

===============================================================================

.- ESTRUCTURAS DINAMICAS EN C: CONCEPTO DE LISTAS
Una lista es un conjunto de nodos, cada uno de los cuales tiene dos campos: uno de informacion y un apuntador al siguient nodo de la lista. Ademas un apuntador externo senala el primer nodo de la lista.

Informacion | Direccion al siguiente nodo

La informacion puede ser cualquier tipo de dato simple (int, char, float, etc.) o estructura de datos (registro, vector, etc.);

La direccion al siguiente nodo es un puntero.

raiz -> 4|->7|->3|->7|*

Como deciamos, una lista es una secuenciea de nodos (en este caso cuatro nodos). La informacion de los nodos en este caso es un entero y siempre contiene un puntero que guarda la direccion del siguiente nodo. raiz es otro puntero externo a la lista que contiene la direccion del primer nodo.

El estado de una lista varia durante la ejecucion del programa.

De esta forma representamos graficamente una lista vacia:
raiz->*

Si insertamos un dodo en la lista quedaria asi:
raiz->4|*

Si insertamos otro nodo al principio con el valor de 9 tenemos:

raiz->9|->4|*

Lo mismo podemos borrar nodos de cualquier parte de la lista.

Tipos de listas
Segun el mecanismo de insercion y extraccion de nodos en la lista tenemos los siguientes tipos:

Listas tipo pila.
Listas tipo cola.
Listas genericas.

Una lista se comporta como una pila si las inserciones y extracciones las hacemos por un mismo lado de la lista (por ejemplo donde apunta raiz). Tambien se las llama listas LIFO (Last In First Out - ultimo en entrar primero en salir).

Una lista se comporta como una cola si las inserciones las hacemos al final y las extracciones las hacemos por el frente de la lista. Tambien se las llama listas FIFO (First In First Out - primero en entrar primero en salir).

Una lista se comporta como generica cuando las inserciones y extracciones se realizan en cualquier parte de la lista. Podemos en algun momento insertar un nodo en medio de la lista, en otro momento al final, borrar uno del frente, borrar uno del fondo o uno interior, etc.

.- ESTRUCTURAS DINAMICAS EN C: LISTAS TIPO PILA
Inicialmente la pila esta vacia y decimos que el puntero raiz apunta a NULL (si apunta a NULL decimos que no tiene una direccion de memoria, en realidad este valor NULL es el valor cero).

#include<stdio.h>
#include<conio.h>
#include<stdlib.h>

struct nodo{
	int info;
	struct nodo *sig;
};

struct nodo *raiz=NULL;

void insertar(int x){
	struct nodo *nuevo;
	nuevo=malloc(sizeof(struct nodo));
	nuevo->info=x;
	
	if(raiz==NULL){
		raiz=nuevo;
		nuevo->sig=NULL;
	}
	else{
		nuevo->sig=raiz;
		raiz=nuevo;
	}
}

void imprimir(){
	struct nodo *reco=raiz;
	
	printf("Lista completa.\n");
	
	while(reco!=NULL){
		printf("%i ", reco->info);
		reco=reco->sig;
	}
	
	printf("\n");
}

int extraer(){
	if(raiz!=NULL){
		int informacion=raiz->info;
		struct nodo *bor=raiz;
		raiz=raiz->sig;
		free(bor);
		return informacion;
	}
	else{
		return -1;
	}
}

void liberar(){
	struct nodo *reco=raiz;
	struct nodo *bor;
	
	while(reco!=NULL){
		bor=reco;
		reco=reco->sig;
		free(bor);
	}
}

int main(){
	insertar(10);
	insertar(40);
	insertar(3);
	
	imprimir();
	
	printf("Extraemos de la pila: %i\n", extraer());
	
	imprimir();
	
	liberar();
	
	getch();
	
	return 0;
}

===============================================================================
